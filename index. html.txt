<!DOCTYPE html>
<html lang="zh-CN">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Merry Christmas</title>
Â  Â  <style>
Â  Â  Â  Â  body {Â 
Â  Â  Â  Â  Â  Â  margin: 0;Â 
Â  Â  Â  Â  Â  Â  overflow: hidden;Â 
Â  Â  Â  Â  Â  Â  background-color: #050505;Â 
Â  Â  Â  Â  Â  Â  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
Â  Â  Â  Â  Â  Â  user-select: none;
Â  Â  Â  Â  }
Â  Â  Â  Â  #canvas-container {Â 
Â  Â  Â  Â  Â  Â  width: 100vw;Â 
Â  Â  Â  Â  Â  Â  height: 100vh;Â 
Â  Â  Â  Â  Â  Â  position: absolute;Â 
Â  Â  Â  Â  Â  Â  top: 0;Â 
Â  Â  Â  Â  Â  Â  left: 0;Â 
Â  Â  Â  Â  Â  Â  z-index: 1;Â 
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #ui-layer {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  bottom: 30px;
Â  Â  Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  z-index: 100;
Â  Â  Â  Â  Â  Â  color: rgba(255, 255, 255, 0.9);
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 10px rgba(0,0,0,0.8);
Â  Â  Â  Â  }
Â  Â  Â  Â  h1 { margin: 0; font-weight: 300; font-size: 1.4rem; letter-spacing: 4px; text-transform: uppercase; }
Â  Â  Â  Â  p { font-size: 0.9rem; color: #aaa; margin-top: 5px; transition: color 0.3s; }

Â  Â  Â  Â  #video-input { display: none; }Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  .loading {
Â  Â  Â  Â  Â  Â  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
Â  Â  Â  Â  Â  Â  color: white; font-size: 1.2rem; z-index: 200; transition: opacity 0.5s;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  #photo-container {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  z-index: 50;
Â  Â  Â  Â  Â  Â  pointer-events: auto;Â 
Â  Â  Â  Â  Â  Â  perspective: 1200px;Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  /* ç…§ç‰‡å®¹å™¨ */
Â  Â  Â  Â  .photo-card {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  Â  Â  width: 80px;Â 
Â  Â  Â  Â  Â  Â  height: auto;
Â  Â  Â  Â  Â  Â  border: none;Â 
Â  Â  Â  Â  Â  Â  padding: 0;Â 
Â  Â  Â  Â  Â  Â  background: transparent;Â 
Â  Â  Â  Â  Â  Â  will-change: transform;
Â  Â  Â  Â  Â  Â  opacity: 0;
Â  Â  Â  Â  Â  Â  margin-left: -40px;Â 
Â  Â  Â  Â  Â  Â  margin-top: -53px;Â 
Â  Â  Â  Â  Â  Â  transform-style: preserve-3d;Â 
Â  Â  Â  Â  Â  Â  backface-visibility: hidden;
Â  Â  Â  Â  Â  Â  transition: opacity 0.6s ease;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* åŠ¨æ€ç‹¬ç«‹ç²’å­ - å‘¼å¸æ„Ÿ */
Â  Â  Â  Â  .frame-particle {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  background-color: #fff;
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  z-index: 4;
Â  Â  Â  Â  Â  Â  animation: particle-heave var(--dur) ease-in-out infinite alternate;
Â  Â  Â  Â  Â  Â  animation-delay: var(--delay);
Â  Â  Â  Â  Â  Â  transform: translateZ(var(--z));
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 3px rgba(255, 255, 255, 0.9);
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes particle-heave {
Â  Â  Â  Â  Â  Â  0% { transform: translateZ(var(--z)) translateY(0px) scale(1); opacity: 0.7; }
Â  Â  Â  Â  Â  Â  100% { transform: translateZ(var(--z)) translateY(var(--moveY)) scale(1.3); opacity: 1; }
Â  Â  Â  Â  }

Â  Â  Â  Â  /* å†…éƒ¨å›¾ç‰‡ */
Â  Â  Â  Â  .photo-card img {
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  object-fit: cover;
Â  Â  Â  Â  Â  Â  border-radius: 2px;Â 
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  Â  Â  opacity: 0.95;
Â  Â  Â  Â  Â  Â  transform: translateZ(0px);Â 
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 10px rgba(0,0,0,0.5);
Â  Â  Â  Â  Â  Â  position: relative;Â 
Â  Â  Â  Â  Â  Â  z-index: 2;Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  /* åŠ¨æ€é£˜æ•£ç²’å­ */
Â  Â  Â  Â  .emit-particle {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  width: 3px;
Â  Â  Â  Â  Â  Â  height: 3px;
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  z-index: 4;Â 
Â  Â  Â  Â  Â  Â  animation-name: particle-drift;
Â  Â  Â  Â  Â  Â  animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94);
Â  Â  Â  Â  Â  Â  animation-fill-mode: forwards;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 5px currentColor;Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  @keyframes particle-drift {
Â  Â  Â  Â  Â  Â  0% { transform: translate3d(0, 0, 0) scale(1); opacity: 0; }
Â  Â  Â  Â  Â  Â  10% { opacity: 1; }Â 
Â  Â  Â  Â  Â  Â  100% { transform: translate3d(var(--tx), var(--ty), var(--tz)) scale(0); opacity: 0; }
Â  Â  Â  Â  }

Â  Â  Â  Â  .photo-card.spawning {
Â  Â  Â  Â  Â  Â  transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s ease;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* å¤§å›¾/èšç„¦æ¨¡å¼æ ·å¼ */
Â  Â  Â  Â  .photo-card.focused {
Â  Â  Â  Â  Â  Â  z-index: 999 !important;
Â  Â  Â  Â  Â  Â  transition: all 0.8s cubic-bezier(0.19, 1, 0.22, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .photo-card.hidden-in-focus {
Â  Â  Â  Â  Â  Â  opacity: 0.1 !important;Â 
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  transition: opacity 0.5s ease;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  /* æ¿€æ´»çŠ¶æ€ï¼ˆæåˆä¸­ï¼‰ */
Â  Â  Â  Â  .photo-card.active-state {
Â  Â  Â  Â  Â  Â  z-index: 2000 !important;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .photo-card.active-state img {
Â  Â  Â  Â  Â  Â  opacity: 1;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
Â  Â  Â  Â  }

Â  Â  Â  Â  #star-cursor { display: none; }

Â  Â  Â  Â  /* è“è‰²è“„åŠ›è¿›åº¦æ¡ */
Â  Â  Â  Â  #hold-progress {
Â  Â  Â  Â  Â  Â  position: fixed;
Â  Â  Â  Â  Â  Â  top: 50%; left: 50%;
Â  Â  Â  Â  Â  Â  transform: translate(-50%, -50%);
Â  Â  Â  Â  Â  Â  width: 100px; height: 100px;
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  border: 4px solid rgba(255, 255, 255, 0.1);
Â  Â  Â  Â  Â  Â  border-top-color: #00ccff;
Â  Â  Â  Â  Â  Â  opacity: 0;
Â  Â  Â  Â  Â  Â  transition: opacity 0.3s;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  z-index: 2000;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 20px rgba(0, 204, 255, 0.3);
Â  Â  Â  Â  }
Â  Â  Â  Â  #hold-progress.active {
Â  Â  Â  Â  Â  Â  opacity: 1;
Â  Â  Â  Â  Â  Â  animation: spin 1s linear infinite;
Â  Â  Â  Â  }
Â  Â  Â  Â  @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }

Â  Â  </style>

Â  Â  <!-- MediaPipe -->
Â  Â  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

Â  Â  <!-- Three.js -->
Â  Â  <script type="importmap">
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  "imports": {
Â  Â  Â  Â  Â  Â  Â  Â  "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
Â  Â  Â  Â  Â  Â  Â  Â  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  </script>
</head>
<body>

Â  Â  <div id="loading" class="loading">åˆå§‹åŒ–æ‘„åƒå¤´ä¸­...<br><span style="font-size:0.8rem; opacity:0.7">(æˆ–è€…æŒ‰ä½å±å¹•æ¨¡æ‹Ÿæåˆ)</span></div>

Â  Â  <div id="ui-layer">
Â  Â  Â  Â  <h1 id="status-text">MERRY CHRISTMAS</h1>
Â  Â  Â  Â  <p id="instruction-text">ğŸ‘Œ+ğŸ‘† å¼ å¼€æ‰‹æŒ‡æ‰“å¼€ | ğŸ‘Œ æåˆå…³é—­</p>
Â  Â  </div>

Â  Â  <div id="photo-container"></div>
Â  Â  <div id="star-cursor"></div>
Â  Â  <div id="hold-progress"></div>

Â  Â  <video id="video-input"></video>
Â  Â  <div id="canvas-container"></div>

Â  Â  <script type="module">
Â  Â  Â  Â  import * as THREE from 'three';
Â  Â  Â  Â  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
Â  Â  Â  Â  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
Â  Â  Â  Â  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
Â  Â  Â  Â  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

Â  Â  Â  Â  const CONFIG = {
Â  Â  Â  Â  Â  Â  particleCount: 30000,
Â  Â  Â  Â  Â  Â  treeHeight: 22,
Â  Â  Â  Â  Â  Â  baseRadius: 9.5,
Â  Â  Â  Â  Â  Â  spiralLoops: 6,
Â  Â  Â  Â  Â  Â  ribbonWidth: 3.6,
Â  Â  Â  Â  Â  Â  waveFrequency: 3,
Â  Â  Â  Â  Â  Â  waveAmplitude: 0.6,
Â  Â  Â  Â  Â  Â  galaxyRadius: 60,Â 
Â  Â  Â  Â  Â  Â  colorInside: new THREE.Color('#88ccff'),
Â  Â  Â  Â  Â  Â  colorOutside: new THREE.Color('#ffffff')
Â  Â  Â  Â  };

Â  Â  Â  Â  const PHOTO_URLS = [
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1512389142860-9c449e58a543?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1513297887112-01c330148138?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1543589077-47d81606c1bf?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1576919224208-a4768390e113?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1482517967863-168a030d9a63?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1575399566916-29a32c4e201c?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1545048702-79362596cdc9?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1511116669931-297f6c32185b?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1574765377595-3c13f9c6d48c?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1513885535751-8b9238bd345a?q=80&w=600&fit=crop",
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1544085311-11a028465b03?q=80&w=600&fit=crop",
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1542289947-2d1421f5e135?q=80&w=600&fit=crop",Â 
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1518645003923-b186b51c1109?q=80&w=600&fit=crop",
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1482638841457-4560b37c050d?q=80&w=600&fit=crop",
Â  Â  Â  Â  Â  Â  "https://images.unsplash.com/photo-1511268594248-6a581452a259?q=80&w=600&fit=crop"
Â  Â  Â  Â  ];

Â  Â  Â  Â  let scene, camera, renderer, composer, controls;
Â  Â  Â  Â  let particleGroup;Â 
Â  Â  Â  Â  let treePoints, trunkPoints, twinklePoints;Â 
Â  Â  Â  Â  let topStarSpherePoints, topStarRing1Points, topStarRing2Points;
Â  Â  Â  Â  let time = 0;

Â  Â  Â  Â  let targetMorph = 0.0;
Â  Â  Â  Â  let currentMorph = 0.0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  let isHandOpen = false;
Â  Â  Â  Â  let isPinching = false;Â 
Â  Â  Â  Â  let isSpread = false; // [æ–°å¢] æ‰‹æŒ‡å¼ å¼€çŠ¶æ€ (é£ŸæŒ‡æ‹‡æŒ‡è·ç¦»å¤§)
Â  Â  Â  Â  let isMouseDown = false;Â 
Â  Â  Â  Â  let isFist = false;Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  let cursorX = window.innerWidth / 2;
Â  Â  Â  Â  let cursorY = window.innerHeight / 2;
Â  Â  Â  Â  let isHandDetected = false;
Â  Â  Â  Â  let handVelocityX = 0;
Â  Â  Â  Â  let lastCursorX = 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  let pinchState = { isPinching: false, startX: 0, startY: 0, startTime: 0 };
Â  Â  Â  Â  let clickState = { lastClickTime: 0, clickCount: 0 };

Â  Â  Â  Â  let galleryState = {
Â  Â  Â  Â  Â  Â  mode: 'WALL',Â 
Â  Â  Â  Â  Â  Â  focusedIndex: -1,
Â  Â  Â  Â  Â  Â  lastSwitchTime: 0
Â  Â  Â  Â  };

Â  Â  Â  Â  let fistHoldStartTime = 0;

Â  Â  Â  Â  let revealedPhotosCount = 0;
Â  Â  Â  Â  const TOTAL_PHOTOS = 15;
Â  Â  Â  Â  let wasPinching = false;
Â  Â  Â  Â  let currentActivePhotoElement = null;
Â  Â  Â  Â  let activePhotoLastEmitTime = 0;

Â  Â  Â  Â  let photoAnchors = [];Â 
Â  Â  Â  Â  let treeAnchors = [];Â 
Â  Â  Â  Â  let floatingPhotos = [];Â 

Â  Â  Â  Â  const photoContainer = document.getElementById('photo-container');
Â  Â  Â  Â  const statusText = document.getElementById('status-text');
Â  Â  Â  Â  const instructionText = document.getElementById('instruction-text');
Â  Â  Â  Â  const cursorEl = document.getElementById('star-cursor');
Â  Â  Â  Â  const holdProgressEl = document.getElementById('hold-progress');

Â  Â  Â  Â  // --- æ‰‹åŠ¿é€»è¾‘ ---
Â  Â  Â  Â  function handleGestureLogic() {
Â  Â  Â  Â  Â  Â  if (revealedPhotosCount < TOTAL_PHOTOS) return;
Â  Â  Â  Â  Â  Â  if (!isHandDetected && !isMouseDown) {
Â  Â  Â  Â  Â  Â  Â  Â  fistHoldStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  holdProgressEl.classList.remove('active');
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const now = Date.now();

Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'WALL') {
Â  Â  Â  Â  Â  Â  Â  Â  // [ä¿®æ”¹] å¼ å¼€æ‰‹æŒ‡ -> æ‰“å¼€ç…§ç‰‡
Â  Â  Â  Â  Â  Â  Â  Â  if (isSpread) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  openPhotoFocus(0);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // æ¡æ‹³é•¿æŒ‰ -> è¿”å›æ ‘ (ä¿æŒä¸å˜)
Â  Â  Â  Â  Â  Â  Â  Â  if (isFist) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (fistHoldStartTime === 0) fistHoldStartTime = now;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  holdProgressEl.classList.add('active');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusText.innerText = "Holding...";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusText.style.color = "#00ccff";

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (now - fistHoldStartTime > 1500) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  triggerTreeMode();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fistHoldStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  holdProgressEl.classList.remove('active');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (fistHoldStartTime !== 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â fistHoldStartTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â holdProgressEl.classList.remove('active');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â statusText.innerText = "MERRY CHRISTMAS";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â statusText.style.color = "#ffffff";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  Â  Â  else if (galleryState.mode === 'FOCUS') {
Â  Â  Â  Â  Â  Â  Â  Â  // [ä¿®æ”¹] æåˆæ‰‹æŒ‡ -> å…³é—­ç…§ç‰‡ (è¿”å›å¢™)
Â  Â  Â  Â  Â  Â  Â  Â  if (isPinching) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  closePhotoFocus();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // æŒ¥æ‰‹åˆ‡æ¢ (ä¿æŒä¸å˜)
Â  Â  Â  Â  Â  Â  Â  Â  else if (Math.abs(handVelocityX) > 20 && (now - galleryState.lastSwitchTime > 1000)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (handVelocityX > 0) switchFocusPhoto(-1);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else switchFocusPhoto(1);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  galleryState.lastSwitchTime = now;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  else if (galleryState.mode === 'TREE') {
Â  Â  Â  Â  Â  Â  Â  Â  // [ä¿®æ”¹] æ ‘æ¨¡å¼ä¸‹ï¼Œå¼ å¼€æ‰‹æŒ‡ -> è¿”å›ç…§ç‰‡å¢™ (å±•å¼€)
Â  Â  Â  Â  Â  Â  Â  Â  if (isSpread) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  returnToWallMode();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function triggerTreeMode() {
Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'TREE') return;
Â  Â  Â  Â  Â  Â  galleryState.mode = 'TREE';
Â  Â  Â  Â  Â  Â  targetMorph = 0.0;
Â  Â  Â  Â  Â  Â  statusText.innerText = "CHRISTMAS TREE";
Â  Â  Â  Â  Â  Â  statusText.style.color = "#00ff00";
Â  Â  Â  Â  Â  Â  instructionText.innerText = "ğŸ„ åœ£è¯å¿«ä¹ï¼(ğŸ‘Œ+ğŸ‘† å¼ å¼€æ‰‹æŒ‡è¿”å›æ˜Ÿç©º)";
Â  Â  Â  Â  Â  Â  controls.autoRotate = true;
Â  Â  Â  Â  Â  Â  controls.autoRotateSpeed = 2.0;
Â  Â  Â  Â  }

Â  Â  Â  Â  function returnToWallMode() {
Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'WALL') return;
Â  Â  Â  Â  Â  Â  galleryState.mode = 'WALL';
Â  Â  Â  Â  Â  Â  targetMorph = 1.0;Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  statusText.innerText = "MERRY CHRISTMAS";
Â  Â  Â  Â  Â  Â  statusText.style.color = "#ffffff";
Â  Â  Â  Â  Â  Â  instructionText.innerText = "ğŸ‘Œ+ğŸ‘† å¼ å¼€æ‰‹æŒ‡æ‰“å¼€ | âœŠ æ¡æ‹³é•¿æŒ‰å˜æ ‘";
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  controls.autoRotate = false;
Â  Â  Â  Â  }

Â  Â  Â  Â  function openPhotoFocus(index) {
Â  Â  Â  Â  Â  Â  if (index < 0 || index >= floatingPhotos.length) return;
Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'FOCUS') return;Â 
Â  Â  Â  Â  Â  Â  galleryState.mode = 'FOCUS';
Â  Â  Â  Â  Â  Â  galleryState.focusedIndex = index;
Â  Â  Â  Â  Â  Â  statusText.innerText = "Focus Mode";
Â  Â  Â  Â  Â  Â  statusText.style.color = "#ffcc00";
Â  Â  Â  Â  Â  Â  instructionText.innerText = "ğŸ‘Œ æåˆæ‰‹æŒ‡è¿”å› | ğŸ‘‹ æŒ¥æ‰‹åˆ‡æ¢";
Â  Â  Â  Â  Â  Â  controls.autoRotate = false;
Â  Â  Â  Â  Â  Â  updateGalleryVisuals();
Â  Â  Â  Â  }

Â  Â  Â  Â  function closePhotoFocus() {
Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'WALL' || galleryState.mode === 'TREE') return;
Â  Â  Â  Â  Â  Â  galleryState.mode = 'WALL';
Â  Â  Â  Â  Â  Â  galleryState.focusedIndex = -1;
Â  Â  Â  Â  Â  Â  targetMorph = 1.0;Â 
Â  Â  Â  Â  Â  Â  statusText.innerText = "MERRY CHRISTMAS";
Â  Â  Â  Â  Â  Â  statusText.style.color = "#ffffff";
Â  Â  Â  Â  Â  Â  instructionText.innerText = "ğŸ‘Œ+ğŸ‘† å¼ å¼€æ‰‹æŒ‡æ‰“å¼€ | âœŠ æ¡æ‹³é•¿æŒ‰å˜æ ‘";Â 
Â  Â  Â  Â  Â  Â  controls.autoRotate = false;
Â  Â  Â  Â  Â  Â  updateGalleryVisuals();
Â  Â  Â  Â  }

Â  Â  Â  Â  function switchFocusPhoto(direction) {
Â  Â  Â  Â  Â  Â  let newIndex = galleryState.focusedIndex + direction;
Â  Â  Â  Â  Â  Â  if (newIndex < 0) newIndex = floatingPhotos.length - 1;
Â  Â  Â  Â  Â  Â  if (newIndex >= floatingPhotos.length) newIndex = 0;
Â  Â  Â  Â  Â  Â  galleryState.focusedIndex = newIndex;
Â  Â  Â  Â  Â  Â  updateGalleryVisuals();
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateGalleryVisuals() {
Â  Â  Â  Â  Â  Â  floatingPhotos.forEach((item, i) => {
Â  Â  Â  Â  Â  Â  Â  Â  const el = item.element;
Â  Â  Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'FOCUS') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (i === galleryState.focusedIndex) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.classList.add('focused');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.classList.remove('hidden-in-focus');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.style.transform = `translate(${window.innerWidth/2}px, ${window.innerHeight/2}px) scale(5.0) rotate(0deg)`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.style.left = 0; el.style.top = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.style.marginLeft = '-40px'; el.style.marginTop = '-53px';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.classList.remove('focused');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.classList.add('hidden-in-focus');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.classList.remove('focused');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.classList.remove('hidden-in-focus');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  function initScene() {
Â  Â  Â  Â  Â  Â  const container = document.getElementById('canvas-container');

Â  Â  Â  Â  Â  Â  scene = new THREE.Scene();
Â  Â  Â  Â  Â  Â  scene.fog = new THREE.FogExp2(0x050505, 0.02);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  particleGroup = new THREE.Group();
Â  Â  Â  Â  Â  Â  scene.add(particleGroup);

Â  Â  Â  Â  Â  Â  const ambientLight = new THREE.AmbientLight(0x404040, 2.0);
Â  Â  Â  Â  Â  Â  scene.add(ambientLight);
Â  Â  Â  Â  Â  Â  const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
Â  Â  Â  Â  Â  Â  dirLight.position.set(10, 20, 10);
Â  Â  Â  Â  Â  Â  scene.add(dirLight);
Â  Â  Â  Â  Â  Â  const backLight = new THREE.DirectionalLight(0x88ccff, 1.0);Â 
Â  Â  Â  Â  Â  Â  backLight.position.set(-10, 10, -20);
Â  Â  Â  Â  Â  Â  scene.add(backLight);

Â  Â  Â  Â  Â  Â  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
Â  Â  Â  Â  Â  Â  camera.position.set(0, 12, 35);
Â  Â  Â  Â  Â  Â  camera.lookAt(0, 10, 0);Â 

Â  Â  Â  Â  Â  Â  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
Â  Â  Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  Â  Â  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
Â  Â  Â  Â  Â  Â  renderer.toneMapping = THREE.ReinhardToneMapping;
Â  Â  Â  Â  Â  Â  container.appendChild(renderer.domElement);

Â  Â  Â  Â  Â  Â  controls = new OrbitControls(camera, renderer.domElement);
Â  Â  Â  Â  Â  Â  controls.enableDamping = true;
Â  Â  Â  Â  Â  Â  controls.dampingFactor = 0.05;
Â  Â  Â  Â  Â  Â  controls.autoRotate = true;
Â  Â  Â  Â  Â  Â  controls.autoRotateSpeed = 1.0;
Â  Â  Â  Â  Â  Â  controls.target.set(0, 10, 0);

Â  Â  Â  Â  Â  Â  const renderScene = new RenderPass(scene, camera);
Â  Â  Â  Â  Â  Â  const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
Â  Â  Â  Â  Â  Â  bloomPass.strength = 1.0;Â Â 
Â  Â  Â  Â  Â  Â  bloomPass.radius = 0.6;
Â  Â  Â  Â  Â  Â  bloomPass.threshold = 0.15;

Â  Â  Â  Â  Â  Â  composer = new EffectComposer(renderer);
Â  Â  Â  Â  Â  Â  composer.addPass(renderScene);
Â  Â  Â  Â  Â  Â  composer.addPass(bloomPass);

Â  Â  Â  Â  Â  Â  createPhotoAnchors();
Â  Â  Â  Â  Â  Â  createTreeAnchors();Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  window.addEventListener('resize', onWindowResize);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  window.addEventListener('mousemove', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  cursorX = e.clientX;
Â  Â  Â  Â  Â  Â  Â  Â  cursorY = e.clientY;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  window.addEventListener('mousedown', (e) => {Â 
Â  Â  Â  Â  Â  Â  Â  Â  isHandOpen = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  isSpread = true; // æ¨¡æ‹Ÿ
Â  Â  Â  Â  Â  Â  Â  Â  handleGestureLogic();Â 
Â  Â  Â  Â  Â  Â  Â  Â  handleInteractionInput(e.clientX, e.clientY, true);Â 
Â  Â  Â  Â  Â  Â  });Â 
Â  Â  Â  Â  Â  Â  window.addEventListener('mouseup', (e) => {Â 
Â  Â  Â  Â  Â  Â  Â  Â  isHandOpen = false;
Â  Â  Â  Â  Â  Â  Â  Â  isSpread = false;
Â  Â  Â  Â  Â  Â  Â  Â  handleInteractionInput(e.clientX, e.clientY, false);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  function addDynamicParticles(container) {
Â  Â  Â  Â  Â  Â  const count = 80;Â 
Â  Â  Â  Â  Â  Â  for(let i=0; i<count; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const p = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  p.className = 'frame-particle';
Â  Â  Â  Â  Â  Â  Â  Â  const size = Math.random() * 2.5 + 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  p.style.width = size + 'px';
Â  Â  Â  Â  Â  Â  Â  Â  p.style.height = size + 'px';
Â  Â  Â  Â  Â  Â  Â  Â  const side = Math.floor(Math.random() * 4);
Â  Â  Â  Â  Â  Â  Â  Â  const spread = 6;Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (side === 0) { p.style.top = (Math.random() * spread - spread/2) + 'px'; p.style.left = (Math.random() * 100) + '%'; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else if (side === 1) { p.style.bottom = (Math.random() * spread - spread/2) + 'px'; p.style.left = (Math.random() * 100) + '%'; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else if (side === 2) { p.style.left = (Math.random() * spread - spread/2) + 'px'; p.style.top = (Math.random() * 100) + '%'; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else { p.style.right = (Math.random() * spread - spread/2) + 'px'; p.style.top = (Math.random() * 100) + '%'; }
Â  Â  Â  Â  Â  Â  Â  Â  const z = (Math.random() - 0.5) * 40;Â 
Â  Â  Â  Â  Â  Â  Â  Â  p.style.setProperty('--z', `${z}px`);
Â  Â  Â  Â  Â  Â  Â  Â  p.style.setProperty('--dur', `${Math.random() * 2 + 2}s`);Â 
Â  Â  Â  Â  Â  Â  Â  Â  p.style.setProperty('--delay', `-${Math.random() * 4}s`);
Â  Â  Â  Â  Â  Â  Â  Â  p.style.setProperty('--moveY', `${(Math.random() - 0.5) * 6}px`);Â 
Â  Â  Â  Â  Â  Â  Â  Â  p.style.opacity = Math.random() * 0.5 + 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  container.appendChild(p);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function createPhotoAnchors() {
Â  Â  Â  Â  Â  Â  const anchorGeo = new THREE.SphereGeometry(0.5);Â 
Â  Â  Â  Â  Â  Â  const anchorMat = new THREE.MeshBasicMaterial({ visible: false, color: 0xff0000 });
Â  Â  Â  Â  Â  Â  const cols = 5;
Â  Â  Â  Â  Â  Â  const rows = 3;
Â  Â  Â  Â  Â  Â  const xSpacing = 5.0;Â 
Â  Â  Â  Â  Â  Â  const ySpacing = 5.5;Â 
Â  Â  Â  Â  Â  Â  const centerX = 0;
Â  Â  Â  Â  Â  Â  const centerY = 10;
Â  Â  Â  Â  Â  Â  const centerZ = -20;Â 
Â  Â  Â  Â  Â  Â  for(let i=0; i<TOTAL_PHOTOS; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const anchor = new THREE.Mesh(anchorGeo, anchorMat);
Â  Â  Â  Â  Â  Â  Â  Â  const col = i % cols;
Â  Â  Â  Â  Â  Â  Â  Â  const row = Math.floor(i / cols);
Â  Â  Â  Â  Â  Â  Â  Â  const xOffset = (col - (cols - 1) / 2) * xSpacing;
Â  Â  Â  Â  Â  Â  Â  Â  const yOffset = ((rows - 1) / 2 - row) * ySpacing;
Â  Â  Â  Â  Â  Â  Â  Â  const x = centerX + xOffset;
Â  Â  Â  Â  Â  Â  Â  Â  const y = centerY + yOffset;
Â  Â  Â  Â  Â  Â  Â  Â  const z = centerZ;Â 
Â  Â  Â  Â  Â  Â  Â  Â  anchor.position.set(x, y, z);
Â  Â  Â  Â  Â  Â  Â  Â  anchor.lookAt(0, 10, 0);Â 
Â  Â  Â  Â  Â  Â  Â  Â  scene.add(anchor);
Â  Â  Â  Â  Â  Â  Â  Â  photoAnchors.push(anchor);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function createTreeAnchors() {
Â  Â  Â  Â  Â  Â  const anchorGeo = new THREE.SphereGeometry(0.2);Â 
Â  Â  Â  Â  Â  Â  const anchorMat = new THREE.MeshBasicMaterial({ visible: false, color: 0x00ff00 });
Â  Â  Â  Â  Â  Â  for(let i=0; i<TOTAL_PHOTOS; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const anchor = new THREE.Mesh(anchorGeo, anchorMat);
Â  Â  Â  Â  Â  Â  Â  Â  const p = i / TOTAL_PHOTOS;
Â  Â  Â  Â  Â  Â  Â  Â  const y = 3 + p * 15;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const r = CONFIG.baseRadius * Math.pow(1.0 - y/CONFIG.treeHeight, 1.2) + 0.5;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const angle = i * 2.5;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const x = Math.cos(angle) * r;
Â  Â  Â  Â  Â  Â  Â  Â  const z = Math.sin(angle) * r;
Â  Â  Â  Â  Â  Â  Â  Â  anchor.position.set(x, y, z);
Â  Â  Â  Â  Â  Â  Â  Â  anchor.lookAt(0, y, 0);
Â  Â  Â  Â  Â  Â  Â  Â  anchor.rotateY(Math.PI);
Â  Â  Â  Â  Â  Â  Â  Â  particleGroup.add(anchor);
Â  Â  Â  Â  Â  Â  Â  Â  treeAnchors.push(anchor);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function getScreenPos(obj) {
Â  Â  Â  Â  Â  Â  const vector = new THREE.Vector3();
Â  Â  Â  Â  Â  Â  vector.setFromMatrixPosition(obj.matrixWorld);
Â  Â  Â  Â  Â  Â  vector.project(camera);
Â  Â  Â  Â  Â  Â  const x = (vector.x * .5 + .5) * window.innerWidth;
Â  Â  Â  Â  Â  Â  const y = (-(vector.y * .5) + .5) * window.innerHeight;
Â  Â  Â  Â  Â  Â  return { x, y };
Â  Â  Â  Â  }

Â  Â  Â  Â  function spawnNextPhoto() {
Â  Â  Â  Â  Â  Â  if (revealedPhotosCount >= TOTAL_PHOTOS) return;

Â  Â  Â  Â  Â  Â  const anchor = photoAnchors[revealedPhotosCount];
Â  Â  Â  Â  Â  Â  const startPos = getScreenPos(anchor);
Â  Â  Â  Â  Â  Â  const centerPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

Â  Â  Â  Â  Â  Â  const div = document.createElement('div');
Â  Â  Â  Â  Â  Â  div.className = 'photo-card active-state spawning';
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const img = document.createElement('img');
Â  Â  Â  Â  Â  Â  img.src = PHOTO_URLS[revealedPhotosCount];
Â  Â  Â  Â  Â  Â  div.appendChild(img);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  addDynamicParticles(div);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  div.style.transform = `translate(${startPos.x}px, ${startPos.y}px) scale(0)`;
Â  Â  Â  Â  Â  Â  div.style.opacity = '1';
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  photoContainer.appendChild(div);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  Â  Â  Â  Â  const rot = (Math.random() - 0.5) * 5;Â 
Â  Â  Â  Â  Â  Â  Â  Â  div.style.transform = `translate(${centerPos.x}px, ${centerPos.y}px) scale(5.0) rotate(${rot}deg)`;
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  currentActivePhotoElement = div;
Â  Â  Â  Â  Â  Â  statusText.innerText = `Memories: ${revealedPhotosCount + 1}/${TOTAL_PHOTOS}`;
Â  Â  Â  Â  Â  Â  statusText.style.color = "#ffcc00";
Â  Â  Â  Â  }

Â  Â  Â  Â  function emitParticleFrom(el) {
Â  Â  Â  Â  Â  Â  const p = document.createElement('div');
Â  Â  Â  Â  Â  Â  p.className = 'emit-particle';
Â  Â  Â  Â  Â  Â  const colors = ['#88ccff', '#ffffff', '#aaddff'];
Â  Â  Â  Â  Â  Â  p.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
Â  Â  Â  Â  Â  Â  p.style.color = p.style.backgroundColor;Â 
Â  Â  Â  Â  Â  Â  const startX = Math.random() * 100;
Â  Â  Â  Â  Â  Â  const startY = Math.random() * 100;
Â  Â  Â  Â  Â  Â  p.style.left = startX + '%';
Â  Â  Â  Â  Â  Â  p.style.top = startY + '%';
Â  Â  Â  Â  Â  Â  const angle = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  const dist = 60 + Math.random() * 40;Â 
Â  Â  Â  Â  Â  Â  const tx = Math.cos(angle) * dist;
Â  Â  Â  Â  Â  Â  const ty = Math.sin(angle) * dist;
Â  Â  Â  Â  Â  Â  const tz = (Math.random() - 0.5) * 80;Â 
Â  Â  Â  Â  Â  Â  p.style.setProperty('--tx', `${tx}px`);
Â  Â  Â  Â  Â  Â  p.style.setProperty('--ty', `${ty}px`);
Â  Â  Â  Â  Â  Â  p.style.setProperty('--tz', `${tz}px`);
Â  Â  Â  Â  Â  Â  const duration = 3 + Math.random() * 2;
Â  Â  Â  Â  Â  Â  p.style.animationDuration = `${duration}s`;
Â  Â  Â  Â  Â  Â  el.appendChild(p);
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  if(p.parentNode) p.parentNode.removeChild(p);
Â  Â  Â  Â  Â  Â  }, duration * 1000);
Â  Â  Â  Â  }

Â  Â  Â  Â  function releasePhotoToFloat() {
Â  Â  Â  Â  Â  Â  if (!currentActivePhotoElement) return;

Â  Â  Â  Â  Â  Â  const div = currentActivePhotoElement;
Â  Â  Â  Â  Â  Â  div.classList.remove('active-state', 'spawning');Â 
Â  Â  Â  Â  Â  Â  div.classList.add('floating');Â 

Â  Â  Â  Â  Â  Â  const anchor = photoAnchors[revealedPhotosCount];
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const phase = Math.random() * Math.PI * 2;

Â  Â  Â  Â  Â  Â  floatingPhotos.push({
Â  Â  Â  Â  Â  Â  Â  Â  element: div,
Â  Â  Â  Â  Â  Â  Â  Â  anchor: anchor,
Â  Â  Â  Â  Â  Â  Â  Â  phase: phase,
Â  Â  Â  Â  Â  Â  Â  Â  releaseTime: time,Â 
Â  Â  Â  Â  Â  Â  Â  Â  lastEmitTime: 0,Â 
Â  Â  Â  Â  Â  Â  Â  Â  startScreenPos: {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: window.innerWidth / 2,Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: window.innerHeight / 2Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  currentActivePhotoElement = null;
Â  Â  Â  Â  Â  Â  revealedPhotosCount++;

Â  Â  Â  Â  Â  Â  if (revealedPhotosCount >= TOTAL_PHOTOS) {
Â  Â  Â  Â  Â  Â  Â  Â  statusText.innerText = "MERRY CHRISTMAS";
Â  Â  Â  Â  Â  Â  Â  Â  statusText.style.color = "#ffcc00";
Â  Â  Â  Â  Â  Â  Â  Â  instructionText.innerText = "ğŸ‘Œ+ğŸ‘† å¼ å¼€æ‰‹æŒ‡æ‰“å¼€ | ğŸ‘Œ æåˆå…³é—­";
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  statusText.innerText = "Entering Universe...";
Â  Â  Â  Â  Â  Â  Â  Â  statusText.style.color = "#88ccff";
Â  Â  Â  Â  Â  Â  Â  Â  instructionText.innerText = `ğŸ‘Œ å†æ¬¡æåˆæ”¶é›†ä¸‹ä¸€å¼  (${revealedPhotosCount}/${TOTAL_PHOTOS})`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- ç²’å­ç³»ç»Ÿä»£ç  (å®Œæ•´ä¿ç•™åŸç‰ˆ) ---
Â  Â  Â  Â  function addGalaxyAttribute(geometry, count, radiusScale = 1.0, yCenterOffset = 10) {
Â  Â  Â  Â  Â  Â  const positions = [];
Â  Â  Â  Â  Â  Â  const rBase = CONFIG.galaxyRadius * radiusScale;
Â  Â  Â  Â  Â  Â  for(let i=0; i<count; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const u = Math.random(); const v = Math.random();
Â  Â  Â  Â  Â  Â  Â  Â  const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
Â  Â  Â  Â  Â  Â  Â  Â  const r = rBase * Math.cbrt(Math.random());Â 
Â  Â  Â  Â  Â  Â  Â  Â  const x = r * Math.sin(phi) * Math.cos(theta);
Â  Â  Â  Â  Â  Â  Â  Â  const y = r * Math.sin(phi) * Math.sin(theta) + yCenterOffset;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const z = r * Math.cos(phi);
Â  Â  Â  Â  Â  Â  Â  Â  positions.push(x, y, z);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  geometry.setAttribute('aGalaxyPos', new THREE.Float32BufferAttribute(positions, 3));
Â  Â  Â  Â  }
Â  Â  Â  Â  function createSparkleTexture() {
Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  canvas.width = 64; canvas.height = 64;
Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
Â  Â  Â  Â  Â  Â  g.addColorStop(0, 'rgba(255, 255, 255, 1)');
Â  Â  Â  Â  Â  Â  g.addColorStop(0.5, 'rgba(100, 160, 255, 0.15)');
Â  Â  Â  Â  Â  Â  g.addColorStop(1, 'rgba(0, 0, 0, 0)');
Â  Â  Â  Â  Â  Â  ctx.fillStyle = g; ctx.fillRect(0, 0, 64, 64);
Â  Â  Â  Â  Â  Â  return new THREE.CanvasTexture(canvas);
Â  Â  Â  Â  }
Â  Â  Â  Â  function createStarTexture() {
Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  canvas.width = 128; canvas.height = 128;
Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  const cx = 64, cy = 64;
Â  Â  Â  Â  Â  Â  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
Â  Â  Â  Â  Â  Â  g.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
Â  Â  Â  Â  Â  Â  g.addColorStop(1, 'rgba(0, 0, 0, 0)');
Â  Â  Â  Â  Â  Â  ctx.fillStyle = g; ctx.fillRect(0, 0, 128, 128);
Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  for (let i = 0; i < 4; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const angle = (i * Math.PI) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(cx + Math.cos(angle) * 60, cy + Math.sin(angle) * 60);
Â  Â  Â  Â  Â  Â  Â  Â  const midAngle = angle + Math.PI / 4;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.quadraticCurveTo(cx, cy, cx + Math.cos(midAngle) * 8, cy + Math.sin(midAngle) * 8);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  ctx.closePath(); ctx.fillStyle = '#ffffff'; ctx.fill();
Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 255, 255, 1.0)'; ctx.fill();
Â  Â  Â  Â  Â  Â  return new THREE.CanvasTexture(canvas);
Â  Â  Â  Â  }
Â  Â  Â  Â  const commonVertexShader = `
Â  Â  Â  Â  Â  Â  attribute float size;
Â  Â  Â  Â  Â  Â  attribute float aRandom;
Â  Â  Â  Â  Â  Â  attribute vec3 color;
Â  Â  Â  Â  Â  Â  attribute vec3 aGalaxyPos;
Â  Â  Â  Â  Â  Â  varying vec3 vColor;
Â  Â  Â  Â  Â  Â  uniform float uTime;
Â  Â  Â  Â  Â  Â  uniform float uMorph;
Â  Â  Â  Â  Â  Â  uniform sampler2D uTexture;
Â  Â  Â  Â  Â  Â  void main() {
Â  Â  Â  Â  Â  Â  Â  Â  vColor = color;
Â  Â  Â  Â  Â  Â  Â  Â  vec3 treePos = position;
Â  Â  Â  Â  Â  Â  Â  Â  if (uMorph < 0.99) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  float wave = sin(uTime * 1.5 + treePos.y * 0.5);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  treePos.y += wave * 0.08;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  float t = uMorph;
Â  Â  Â  Â  Â  Â  Â  Â  t = t * t * (3.0 - 2.0 * t);
Â  Â  Â  Â  Â  Â  Â  Â  vec3 pos = mix(treePos, aGalaxyPos, t);
Â  Â  Â  Â  Â  Â  Â  Â  if (uMorph > 0.01) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pos.x += sin(uTime * 0.5 + aRandom * 10.0) * 0.1 * uMorph;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pos.z += cos(uTime * 0.3 + aRandom * 10.0) * 0.1 * uMorph;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
Â  Â  Â  Â  Â  Â  Â  Â  float baseSize = size * (350.0 / -mvPosition.z);
Â  Â  Â  Â  Â  Â  Â  Â  float twinkle = sin(uTime * 3.0 + aRandom * 10.0);
Â  Â  Â  Â  Â  Â  Â  Â  float flashSize = baseSize * (0.8 + twinkle * 0.3);
Â  Â  Â  Â  Â  Â  Â  Â  gl_PointSize = flashSize;
Â  Â  Â  Â  Â  Â  Â  Â  gl_Position = projectionMatrix * mvPosition;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  `;
Â  Â  Â  Â  const commonFragmentShader = `
Â  Â  Â  Â  Â  Â  uniform sampler2D uTexture;
Â  Â  Â  Â  Â  Â  varying vec3 vColor;
Â  Â  Â  Â  Â  Â  void main() {
Â  Â  Â  Â  Â  Â  Â  Â  vec4 texColor = texture2D(uTexture, gl_PointCoord);
Â  Â  Â  Â  Â  Â  Â  Â  if (texColor.a < 0.05) discard;
Â  Â  Â  Â  Â  Â  Â  Â  gl_FragColor = vec4(vColor, 1.0) * texColor;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  `;
Â  Â  Â  Â  function createTrunk() {
Â  Â  Â  Â  Â  Â  const geometry = new THREE.BufferGeometry();
Â  Â  Â  Â  Â  Â  const positions = []; const colors = []; const sizes = []; const randoms = [];
Â  Â  Â  Â  Â  Â  const texture = createSparkleTexture();
Â  Â  Â  Â  Â  Â  for (let i = 0; i < 400; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const hRatio = Math.random(); const y = -2.0 + hRatio * 17.4;
Â  Â  Â  Â  Â  Â  Â  Â  const currentR = 3 * (1 - hRatio) + 0.3 * hRatio;
Â  Â  Â  Â  Â  Â  Â  Â  const angle = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  const r = currentR * Math.sqrt(Math.random()) + (Math.random() - 0.5) * 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  let x = Math.cos(angle) * r; let z = Math.sin(angle) * r;
Â  Â  Â  Â  Â  Â  Â  Â  if (hRatio < 0.15) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const scatter = Math.pow(1.0 - hRatio / 0.15, 2.0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x += (Math.random() - 0.5) * 4.0 * scatter; z += (Math.random() - 0.5) * 4.0 * scatter;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  positions.push(x, y, z);
Â  Â  Â  Â  Â  Â  Â  Â  const brightness = 2 + Math.random() * 0.1;Â 
Â  Â  Â  Â  Â  Â  Â  Â  colors.push(0.1 * brightness, 0.2 * brightness, 0.5 * brightness);
Â  Â  Â  Â  Â  Â  Â  Â  sizes.push(Math.random() * 1 + 0.6);
Â  Â  Â  Â  Â  Â  Â  Â  randoms.push(Math.random());
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
Â  Â  Â  Â  Â  Â  addGalaxyAttribute(geometry, 400, 1.0, 10);
Â  Â  Â  Â  Â  Â  const material = new THREE.ShaderMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture } },
Â  Â  Â  Â  Â  Â  Â  Â  vertexShader: commonVertexShader,
Â  Â  Â  Â  Â  Â  Â  Â  fragmentShader: commonFragmentShader,
Â  Â  Â  Â  Â  Â  Â  Â  depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  trunkPoints = new THREE.Points(geometry, material);
Â  Â  Â  Â  Â  Â  particleGroup.add(trunkPoints);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function createTree() {
Â  Â  Â  Â  Â  Â  const geometry = new THREE.BufferGeometry();
Â  Â  Â  Â  Â  Â  const positions = []; const colors = []; const sizes = []; const randoms = [];
Â  Â  Â  Â  Â  Â  const texture = createSparkleTexture();
Â  Â  Â  Â  Â  Â  for (let i = 0; i < CONFIG.particleCount; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const p = i / CONFIG.particleCount;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const angle = p * Math.PI * 2 * CONFIG.spiralLoops;
Â  Â  Â  Â  Â  Â  Â  Â  const baseRadius = CONFIG.baseRadius * Math.pow(1.0 - p, 1.2);Â 
Â  Â  Â  Â  Â  Â  Â  Â  const baseHeight = p * CONFIG.treeHeight;
Â  Â  Â  Â  Â  Â  Â  Â  const wavePhase = angle * 2.5;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const currentAmp = CONFIG.waveAmplitude * Math.pow(1.0 - p, 1.0);
Â  Â  Â  Â  Â  Â  Â  Â  const yWave = Math.sin(wavePhase) * currentAmp;
Â  Â  Â  Â  Â  Â  Â  Â  const rWave = Math.cos(wavePhase) * currentAmp * 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  let centerY = baseHeight + yWave; let centerR = baseRadius + rWave;
Â  Â  Â  Â  Â  Â  Â  Â  let widthFactor = p > 0.4 ? 1.0 - (p - 0.4) * 0.5 : 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  const currentWidth = CONFIG.ribbonWidth * widthFactor;
Â  Â  Â  Â  Â  Â  Â  Â  const v = Math.random() - 0.5;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const twistAmp = 0.5 * Math.pow(1.0 - p, 2.0);
Â  Â  Â  Â  Â  Â  Â  Â  const tiltAngle = Math.cos(wavePhase) * twistAmp;
Â  Â  Â  Â  Â  Â  Â  Â  const rOffset = v * currentWidth * Math.cos(tiltAngle);
Â  Â  Â  Â  Â  Â  Â  Â  const yOffset = v * currentWidth * Math.sin(tiltAngle);
Â  Â  Â  Â  Â  Â  Â  Â  let rFinal = centerR + rOffset; let yFinal = centerY + yOffset;
Â  Â  Â  Â  Â  Â  Â  Â  const normalizedPos = v + 0.5;Â 
Â  Â  Â  Â  Â  Â  Â  Â  yFinal -= Math.pow(normalizedPos, 2) * currentWidth * 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  yFinal += (Math.random() - 0.5) * 0.15;
Â  Â  Â  Â  Â  Â  Â  Â  let x = Math.cos(angle) * rFinal; let z = Math.sin(angle) * rFinal;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // [é‡ç‚¹æ¢å¤] å°¾ç«¯æ¶ˆæ•£é€»è¾‘
Â  Â  Â  Â  Â  Â  Â  Â  const tailRegion = 0.15; let scatterFactor = 0;
Â  Â  Â  Â  Â  Â  Â  Â  if (p < tailRegion) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  scatterFactor = Math.pow(1.0 - (p / tailRegion), 2.0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const flare = 0.7 * scatterFactor;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x += Math.cos(angle) * flare; z += Math.sin(angle) * flare;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const chaosRadius = 3.0 * scatterFactor; x += (Math.random() - 0.5) * chaosRadius; z += (Math.random() - 0.5) * chaosRadius;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  yFinal += (Math.random() - 0.5) * scatterFactor * 0.2;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  positions.push(x, yFinal, z);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const mixFactor = Math.random();
Â  Â  Â  Â  Â  Â  Â  Â  const mixedColor = CONFIG.colorInside.clone().lerp(CONFIG.colorOutside, mixFactor);
Â  Â  Â  Â  Â  Â  Â  Â  const brightnessFactor = (1.0 - Math.pow(p, 1.8) * 0.6) * 0.6;
Â  Â  Â  Â  Â  Â  Â  Â  mixedColor.multiplyScalar(brightnessFactor);
Â  Â  Â  Â  Â  Â  Â  Â  if (scatterFactor > 0) mixedColor.multiplyScalar(1.0 - scatterFactor * 0.7);
Â  Â  Â  Â  Â  Â  Â  Â  colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
Â  Â  Â  Â  Â  Â  Â  Â  let size = Math.random() * 1.0 + 0.2;Â 
Â  Â  Â  Â  Â  Â  Â  Â  size *= (1.0 - p * 0.3);
Â  Â  Â  Â  Â  Â  Â  Â  if (scatterFactor > 0) size *= (1.0 - scatterFactor * 0.6);
Â  Â  Â  Â  Â  Â  Â  Â  sizes.push(size);
Â  Â  Â  Â  Â  Â  Â  Â  randoms.push(Math.random());
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
Â  Â  Â  Â  Â  Â  addGalaxyAttribute(geometry, CONFIG.particleCount, 1.0, 10);
Â  Â  Â  Â  Â  Â  const material = new THREE.ShaderMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture } },
Â  Â  Â  Â  Â  Â  Â  Â  vertexShader: commonVertexShader,
Â  Â  Â  Â  Â  Â  Â  Â  fragmentShader: commonFragmentShader,
Â  Â  Â  Â  Â  Â  Â  Â  depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  treePoints = new THREE.Points(geometry, material);
Â  Â  Â  Â  Â  Â  particleGroup.add(treePoints);Â 
Â  Â  Â  Â  }
Â  Â  Â  Â  function createTwinkles() {
Â  Â  Â  Â  Â  Â  const geometry = new THREE.BufferGeometry();
Â  Â  Â  Â  Â  Â  const positions = []; const colors = []; const sizes = []; const randoms = [];
Â  Â  Â  Â  Â  Â  const count = 500; const texture = createStarTexture();
Â  Â  Â  Â  Â  Â  for (let i = 0; i < count; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const p = Math.random(); const y = p * CONFIG.treeHeight;
Â  Â  Â  Â  Â  Â  Â  Â  const maxR = CONFIG.baseRadius * (1.0 - p) * 1.2;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const r = Math.sqrt(Math.random()) * maxR; const angle = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  let x = Math.cos(angle) * r; let z = Math.sin(angle) * r;
Â  Â  Â  Â  Â  Â  Â  Â  if (p < 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const spread = 2.0 * Math.pow(1.0 - p / 0.1, 2.0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â x += (Math.random() - 0.5) * spread; z += (Math.random() - 0.5) * spread;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  positions.push(x, y, z);
Â  Â  Â  Â  Â  Â  Â  Â  colors.push(0.9, 0.95, 1.0);Â 
Â  Â  Â  Â  Â  Â  Â  Â  sizes.push(Math.random() < 0.05 ? Math.random() * 1.5 + 1.2 : Math.random() * 0.8 + 0.4);
Â  Â  Â  Â  Â  Â  Â  Â  randoms.push(Math.random());
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
Â  Â  Â  Â  Â  Â  geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
Â  Â  Â  Â  Â  Â  addGalaxyAttribute(geometry, count, 1.0, 10);
Â  Â  Â  Â  Â  Â  const material = new THREE.ShaderMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture } },
Â  Â  Â  Â  Â  Â  Â  Â  vertexShader: commonVertexShader,
Â  Â  Â  Â  Â  Â  Â  Â  fragmentShader: commonFragmentShader,
Â  Â  Â  Â  Â  Â  Â  Â  depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  twinklePoints = new THREE.Points(geometry, material);
Â  Â  Â  Â  Â  Â  particleGroup.add(twinklePoints);
Â  Â  Â  Â  }
Â  Â  Â  Â  function createTopParticles() {
Â  Â  Â  Â  Â  Â  const texture = createSparkleTexture();
Â  Â  Â  Â  Â  Â  const starTexture = createStarTexture();
Â  Â  Â  Â  Â  Â  const particleMaterial = new THREE.ShaderMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture } },
Â  Â  Â  Â  Â  Â  Â  Â  vertexShader: commonVertexShader,
Â  Â  Â  Â  Â  Â  Â  Â  fragmentShader: commonFragmentShader,
Â  Â  Â  Â  Â  Â  Â  Â  depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  const sGeo = new THREE.BufferGeometry();
Â  Â  Â  Â  Â  Â  const sPos = []; const sColors = []; const sSizes = []; const sRandoms = [];
Â  Â  Â  Â  Â  Â  const sphereCount = 2000; const radius = 1.2;
Â  Â  Â  Â  Â  Â  for(let i=0; i<sphereCount; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const u = Math.random(); const v = Math.random();
Â  Â  Â  Â  Â  Â  Â  Â  const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
Â  Â  Â  Â  Â  Â  Â  Â  let rRatio = Math.pow(Math.random(), 0.4); let r = radius * rRatio;
Â  Â  Â  Â  Â  Â  Â  Â  const x = r * Math.sin(phi) * Math.cos(theta);
Â  Â  Â  Â  Â  Â  Â  Â  const y = r * Math.sin(phi) * Math.sin(theta);
Â  Â  Â  Â  Â  Â  Â  Â  const z = r * Math.cos(phi);
Â  Â  Â  Â  Â  Â  Â  Â  sPos.push(x, y, z);Â 
Â  Â  Â  Â  Â  Â  Â  Â  const distNorm = r / radius; const baseB = 0.5 * (1.0 + distNorm * 0.6);
Â  Â  Â  Â  Â  Â  Â  Â  sColors.push(baseB * 0.2, baseB * 0.6, baseB * 1.0);Â 
Â  Â  Â  Â  Â  Â  Â  Â  sSizes.push(Math.random() * 0.4 + 0.2); sRandoms.push(Math.random());
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
Â  Â  Â  Â  Â  Â  sGeo.setAttribute('color', new THREE.Float32BufferAttribute(sColors, 3));
Â  Â  Â  Â  Â  Â  sGeo.setAttribute('size', new THREE.Float32BufferAttribute(sSizes, 1));
Â  Â  Â  Â  Â  Â  sGeo.setAttribute('aRandom', new THREE.Float32BufferAttribute(sRandoms, 1));
Â  Â  Â  Â  Â  Â  const objY = CONFIG.treeHeight + 1.5;
Â  Â  Â  Â  Â  Â  const galaxyLocalY = 10 - objY;
Â  Â  Â  Â  Â  Â  addGalaxyAttribute(sGeo, sphereCount, 1.0, galaxyLocalY);
Â  Â  Â  Â  Â  Â  topStarSpherePoints = new THREE.Points(sGeo, particleMaterial);
Â  Â  Â  Â  Â  Â  topStarSpherePoints.position.set(0, objY, 0);Â 
Â  Â  Â  Â  Â  Â  particleGroup.add(topStarSpherePoints);Â 

Â  Â  Â  Â  Â  Â  const ringMaterial = particleMaterial.clone();
Â  Â  Â  Â  Â  Â  ringMaterial.uniforms.uTexture.value = starTexture;
Â  Â  Â  Â  Â  Â  const createRing = (radius, tiltX, tiltZ) => {
Â  Â  Â  Â  Â  Â  Â  Â  const rGeo = new THREE.BufferGeometry();
Â  Â  Â  Â  Â  Â  Â  Â  const rPos = []; const rColors = []; const rSizes = []; const rRandoms = [];
Â  Â  Â  Â  Â  Â  Â  Â  const ringCount = 400;
Â  Â  Â  Â  Â  Â  Â  Â  for(let i=0; i<ringCount; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const angle = (i / ringCount) * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const scatterR = (Math.random() - 0.5) + (Math.random() - 0.5);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const r = radius + scatterR * 0.5;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let x = Math.cos(angle) * r; let y = (Math.random() - 0.5) * 0.4; let z = Math.sin(angle) * r;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let y1 = y * Math.cos(tiltX) - z * Math.sin(tiltX);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let z1 = y * Math.sin(tiltX) + z * Math.cos(tiltX);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let x2 = x * Math.cos(tiltZ) - y1 * Math.sin(tiltZ);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let y2 = x * Math.sin(tiltZ) + y1 * Math.cos(tiltZ);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rPos.push(x2, y2, z1);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distFactor = 1.0 - Math.abs(scatterR) * 0.8; const brightness = 0.4 * distFactor;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rColors.push(brightness, brightness * 1.1, brightness * 1.2);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rSizes.push(Math.random() * 0.6 + 0.4); rRandoms.push(Math.random());
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  rGeo.setAttribute('position', new THREE.Float32BufferAttribute(rPos, 3));
Â  Â  Â  Â  Â  Â  Â  Â  rGeo.setAttribute('color', new THREE.Float32BufferAttribute(rColors, 3));
Â  Â  Â  Â  Â  Â  Â  Â  rGeo.setAttribute('size', new THREE.Float32BufferAttribute(rSizes, 1));
Â  Â  Â  Â  Â  Â  Â  Â  rGeo.setAttribute('aRandom', new THREE.Float32BufferAttribute(rRandoms, 1));
Â  Â  Â  Â  Â  Â  Â  Â  addGalaxyAttribute(rGeo, ringCount, 1.0, galaxyLocalY);
Â  Â  Â  Â  Â  Â  Â  Â  return new THREE.Points(rGeo, ringMaterial);
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  topStarRing1Points = createRing(2.0, Math.PI * 0.25, Math.PI * 0.1);
Â  Â  Â  Â  Â  Â  topStarRing1Points.position.set(0, objY, 0);
Â  Â  Â  Â  Â  Â  particleGroup.add(topStarRing1Points);Â 
Â  Â  Â  Â  Â  Â  topStarRing2Points = createRing(2.0, -Math.PI * 0.25, -Math.PI * 0.1);
Â  Â  Â  Â  Â  Â  topStarRing2Points.position.set(0, objY, 0);
Â  Â  Â  Â  Â  Â  particleGroup.add(topStarRing2Points);Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  const vector = new THREE.Vector3();

Â  Â  Â  Â  function animate() {
Â  Â  Â  Â  Â  Â  requestAnimationFrame(animate);
Â  Â  Â  Â  Â  Â  time += 0.008;

Â  Â  Â  Â  Â  Â  const isInteracting = isPinching || isMouseDown;

Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'WALL') {
Â  Â  Â  Â  Â  Â  Â  Â  if (isInteracting && !wasPinching) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnNextPhoto();
Â  Â  Â  Â  Â  Â  Â  Â  } else if (!isInteracting && wasPinching) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  releasePhotoToFloat();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  handleGestureLogic();
Â  Â  Â  Â  Â  Â  } else if (galleryState.mode === 'FOCUS') {
Â  Â  Â  Â  Â  Â  Â  Â  handleGestureLogic();
Â  Â  Â  Â  Â  Â  } else if (galleryState.mode === 'TREE') {
Â  Â  Â  Â  Â  Â  Â  Â  handleGestureLogic();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  wasPinching = isInteracting;

Â  Â  Â  Â  Â  Â  if (isHandOpen || isMouseDown || revealedPhotosCount > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  targetMorph = 1.0;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  targetMorph = 0.0;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'TREE') {
Â  Â  Â  Â  Â  Â  Â  Â  targetMorph = 0.0;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const lerpSpeed = targetMorph === 0.0 ? 0.15 : 0.05;
Â  Â  Â  Â  Â  Â  currentMorph += (targetMorph - currentMorph) * lerpSpeed;

Â  Â  Â  Â  Â  Â  const updateUniforms = (obj) => {
Â  Â  Â  Â  Â  Â  Â  Â  if(obj && obj.material && obj.material.uniforms && obj.material.uniforms.uMorph) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.material.uniforms.uMorph.value = currentMorph;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.material.uniforms.uTime.value = time;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  particleGroup.children.forEach(updateUniforms);

Â  Â  Â  Â  Â  Â  if (currentMorph < 0.9) {
Â  Â  Â  Â  Â  Â  Â  Â  const rotSpeed = (1.0 - currentMorph) * 0.2;Â 
Â  Â  Â  Â  Â  Â  Â  Â  if(topStarSpherePoints) topStarSpherePoints.rotation.y = time * rotSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  if(topStarRing1Points) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  topStarRing1Points.rotation.y = time * 0.3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  topStarRing1Points.rotation.x = Math.sin(time * 0.5) * 0.1;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if(topStarRing2Points) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  topStarRing2Points.rotation.y = -time * 0.3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  topStarRing2Points.rotation.z = Math.cos(time * 0.5) * 0.1;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const treeCamPos = new THREE.Vector3(0, 12, 35);
Â  Â  Â  Â  Â  Â  const galaxyCamPos = new THREE.Vector3(0, 10, 0);Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const cameraDelay = 0.45;
Â  Â  Â  Â  Â  Â  let cameraProgress = 0;
Â  Â  Â  Â  Â  Â  if (currentMorph > cameraDelay) {
Â  Â  Â  Â  Â  Â  Â  Â  cameraProgress = (currentMorph - cameraDelay) / (1.0 - cameraDelay);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const smoothT = cameraProgress * cameraProgress * (3.0 - 2.0 * cameraProgress);Â 

Â  Â  Â  Â  Â  Â  if (currentMorph > 0.01) {
Â  Â  Â  Â  Â  Â  Â  Â  controls.enabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  camera.position.lerpVectors(treeCamPos, galaxyCamPos, smoothT);
Â  Â  Â  Â  Â  Â  Â  Â  const treeTarget = new THREE.Vector3(0, 10, 0);
Â  Â  Â  Â  Â  Â  Â  Â  const galaxyTarget = new THREE.Vector3(0, 10, -20);Â 
Â  Â  Â  Â  Â  Â  Â  Â  const currentTarget = new THREE.Vector3().lerpVectors(treeTarget, galaxyTarget, smoothT);
Â  Â  Â  Â  Â  Â  Â  Â  camera.lookAt(currentTarget);

Â  Â  Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'WALL') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  particleGroup.rotation.y = time * 0.05 * currentMorph;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  else if (galleryState.mode === 'TREE') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  particleGroup.rotation.y += 0.005;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  updateFloatingPhotos();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  controls.enabled = true;
Â  Â  Â  Â  Â  Â  Â  Â  scene.rotation.y = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â if (galleryState.mode === 'TREE') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â particleGroup.rotation.y += 0.005;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â updateFloatingPhotos();
Â  Â  Â  Â  Â  Â  Â  Â  Â } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â particleGroup.rotation.y = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  controls.update();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  composer.render();
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateFloatingPhotos() {
Â  Â  Â  Â  Â  Â  floatingPhotos.forEach((item, index) => {
Â  Â  Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'FOCUS' && index !== galleryState.focusedIndex) return;
Â  Â  Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'FOCUS' && index === galleryState.focusedIndex) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!item.lastEmitTime || time - item.lastEmitTime > 0.06) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emitParticleFrom(item.element);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.lastEmitTime = time;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  let anchor;
Â  Â  Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'TREE') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  anchor = treeAnchors[index];
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  anchor = photoAnchors[index];
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const el = item.element;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const destPos = getScreenPos(anchor);
Â  Â  Â  Â  Â  Â  Â  Â  vector.setFromMatrixPosition(anchor.matrixWorld);
Â  Â  Â  Â  Â  Â  Â  Â  vector.project(camera);
Â  Â  Â  Â  Â  Â  Â  Â  const dist = camera.position.distanceTo(vector);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const elapsed = time - item.releaseTime;Â 
Â  Â  Â  Â  Â  Â  Â  Â  let progress = Math.min(1.0, elapsed / 0.4);Â 
Â  Â  Â  Â  Â  Â  Â  Â  progress = 1 - Math.pow(1 - progress, 3);

Â  Â  Â  Â  Â  Â  Â  Â  const currentX = destPos.x;
Â  Â  Â  Â  Â  Â  Â  Â  const currentY = destPos.y;

Â  Â  Â  Â  Â  Â  Â  Â  const heaveAmp = galleryState.mode === 'TREE' ? 2.0 : 6.0;
Â  Â  Â  Â  Â  Â  Â  Â  const heaveY = Math.sin(time * 2.0 + item.phase) * heaveAmp;Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const rotX = Math.sin(time * 1.5 + item.phase) * 8.0;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const rotY = Math.cos(time * 1.2 + item.phase) * 10.0;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const rotZ = Math.sin(time * 0.5 + item.phase) * 5.0;Â 

Â  Â  Â  Â  Â  Â  Â  Â  let baseScale = galleryState.mode === 'TREE' ? 10 : 14;
Â  Â  Â  Â  Â  Â  Â  Â  let scale = baseScale / dist;Â 
Â  Â  Â  Â  Â  Â  Â  Â  scale = Math.max(0.1, Math.min(1.0, scale));
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  el.style.transform = `
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  translate3d(${currentX}px, ${currentY + heaveY}px, 0)Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  scale(${scale})Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rotateX(${rotX}deg)Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rotateY(${rotY}deg)Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rotateZ(${rotZ}deg)
Â  Â  Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  el.style.zIndex = Math.floor(100 - dist);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (vector.z > 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.style.opacity = 0;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.style.opacity = 0.95;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (!item.lastEmitTime || time - item.lastEmitTime > 0.06) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emitParticleFrom(el);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.lastEmitTime = time;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if(currentActivePhotoElement) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if(time - activePhotoLastEmitTime > 0.06) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â emitParticleFrom(currentActivePhotoElement);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â activePhotoLastEmitTime = time;
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function onWindowResize() {
Â  Â  Â  Â  Â  Â  camera.aspect = window.innerWidth / window.innerHeight;
Â  Â  Â  Â  Â  Â  camera.updateProjectionMatrix();
Â  Â  Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  Â  Â  composer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  }

Â  Â  Â  Â  function initMediaPipe() {
Â  Â  Â  Â  Â  Â  const videoElement = document.getElementById('video-input');
Â  Â  Â  Â  Â  Â  const loading = document.getElementById('loading');

Â  Â  Â  Â  Â  Â  const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
Â  Â  Â  Â  Â  Â  hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
Â  Â  Â  Â  Â  Â  hands.onResults(onResults);

Â  Â  Â  Â  Â  Â  const cameraUtils = new Camera(videoElement, {
Â  Â  Â  Â  Â  Â  Â  Â  onFrame: async () => await hands.send({image: videoElement}),
Â  Â  Â  Â  Â  Â  Â  Â  width: 640, height: 480
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  cameraUtils.start().then(() => {
Â  Â  Â  Â  Â  Â  Â  Â  loading.style.opacity = 0;
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => loading.style.display = 'none', 500);
Â  Â  Â  Â  Â  Â  }).catch(e => {
Â  Â  Â  Â  Â  Â  Â  Â  console.error(e);
Â  Â  Â  Â  Â  Â  Â  Â  loading.innerHTML = "æ‘„åƒå¤´ä¸å¯ç”¨<br>è¯·ä½¿ç”¨é¼ æ ‡ç‚¹å‡»å±å¹•äº¤äº’";
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  function onResults(results) {
Â  Â  Â  Â  Â  Â  Â  Â  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isHandDetected = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const landmarks = results.multiHandLandmarks[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const wrist = landmarks[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const indexTip = landmarks[8];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cursorX = (1.0 - indexTip.x) * window.innerWidth;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cursorY = indexTip.y * window.innerHeight;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  handVelocityX = cursorX - lastCursorX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastCursorX = cursorX;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const tips = [4, 8, 12, 16, 20];Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let avgDist = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tips.forEach(idx => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const tip = landmarks[idx];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  avgDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  avgDist /= 5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const pinchDist = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentlyPinching = pinchDist < 0.05;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentlyPinching !== isPinching) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  handleInteractionInput(cursorX, cursorY, currentlyPinching);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isPinching = currentlyPinching;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // [æ–°å¢] ç²¾ç¡®å®šä¹‰å¼ æ‰‹ä¸æ¡æ‹³
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isSpread = pinchDist > 0.20; // æ‹‡æŒ‡é£ŸæŒ‡å¼ å¼€å¹…åº¦å¤§ -> æ”¾å¤§/å±•å¼€
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isHandOpen = avgDist > 0.35; // æ•´ä½“æ‰‹æŒå¼ å¼€
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isFist = avgDist < 0.18;Â  Â  Â // æ¡æ‹³

Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isHandDetected = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  handVelocityX = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isMouseDown) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isPinching = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isHandOpen = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isFist = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isSpread = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function handleInteractionInput(x, y, isClickingNow) {
Â  Â  Â  Â  Â  Â  cursorX = x; cursorY = y;
Â  Â  Â  Â  Â  Â  if (isClickingNow) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!pinchState.isPinching) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pinchState.isPinching = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pinchState.startTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  if (pinchState.isPinching) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pinchState.isPinching = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Date.now() - pinchState.startTime < 300) handleTap();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function handleTap() {
Â  Â  Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  Â  Â  if (now - clickState.lastClickTime < 400) {
Â  Â  Â  Â  Â  Â  Â  Â  handleDoubleClick();
Â  Â  Â  Â  Â  Â  Â  Â  clickState.clickCount = 0;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  clickState.clickCount = 1;
Â  Â  Â  Â  Â  Â  Â  Â  clickState.lastClickTime = now;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function handleDoubleClick() {
Â  Â  Â  Â  Â  Â  if (galleryState.mode === 'WALL') {
Â  Â  Â  Â  Â  Â  Â  Â  const targetIdx = findHoveredPhotoIndex();
Â  Â  Â  Â  Â  Â  Â  Â  if (targetIdx !== -1) openPhotoFocus(targetIdx);
Â  Â  Â  Â  Â  Â  } else if (galleryState.mode === 'FOCUS') {
Â  Â  Â  Â  Â  Â  Â  Â  closePhotoFocus();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // [ä¿®å¤] è¡¥å›è¾…åŠ©å‡½æ•°
Â  Â  Â  Â  function findHoveredPhotoIndex() {
Â  Â  Â  Â  Â  Â  for (let i = floatingPhotos.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  const item = floatingPhotos[i];
Â  Â  Â  Â  Â  Â  Â  Â  const rect = item.element.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  Â  Â  const buffer = 20;Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (cursorX >= rect.left - buffer && cursorX <= rect.right + buffer &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cursorY >= rect.top - buffer && cursorY <= rect.bottom + buffer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return i;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return -1;
Â  Â  Â  Â  }

Â  Â  Â  Â  initScene();
Â  Â  Â  Â  createTrunk();
Â  Â  Â  Â  createTree();
Â  Â  Â  Â  createTwinkles();
Â  Â  Â  Â  createTopParticles();
Â  Â  Â  Â  animate();
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(initMediaPipe, 1000);

Â  Â  </script>
</body>
</html>