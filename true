<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            user-select: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        h1 { margin: 0; font-weight: 300; font-size: 1.4rem; letter-spacing: 4px; text-transform: uppercase; }
        p { font-size: 0.9rem; color: #aaa; margin-top: 5px; transition: color 0.3s; }

        #video-input { display: none; } 
        
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2rem; z-index: 20; transition: opacity 0.5s;
        }

        /* Èü≥‰πêÊéßÂà∂ÊåâÈíÆÊ†∑Âºè */
        #music-control {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 50;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
            font-size: 24px;
            color: white;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }
        #music-control:hover { opacity: 1.0; }
        .music-playing { animation: spin 4s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- [‰øÆÊîπ] ËæÖÂä©Â∑•ÂÖ∑Â∫ì‰ΩøÁî®ÈÄöÁî®ÈìæÊé•ÔºåÊ†∏ÂøÉÁÆóÊ≥ïÂ∫ì(Hands, Face)ÈîÅÂÆöÁâàÊú¨‰ª•ÂåπÈÖç locateFile -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    
    <!-- ÈîÅÂÆö Hands Âíå Face Detection ÁâàÊú¨ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4.1646425229/face_detection.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading" class="loading">LOADING (camera)...</div>

    <div id="ui-layer">
        <h1 id="status-text">merry christmas</h1>
        <p id="instruction-text">üñêÔ∏è OPEN YOUR HAND</p>
    </div>
    
    <!-- Èü≥‰πêÊéßÂà∂ÊåâÈíÆ -->
    <div id="music-control" title="Toggle Music">üéµ</div>

    <!-- ËÉåÊôØÈü≥‰πê -->
    <audio id="bgm" loop preload="auto">
        <source src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_febc508520.mp3?filename=christmas-jazz-127988.mp3" type="audio/mp3">
    </audio>

    <video id="video-input"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- ÈÖçÁΩÆÈ°π ---
        const CONFIG = {
            particleCount: 30000,
            treeHeight: 22,
            baseRadius: 9.5,
            spiralLoops: 6,
            ribbonWidth: 3.6,
            waveFrequency: 3,
            waveAmplitude: 0.6,
            galaxyRadius: 60, 
            colorInside: new THREE.Color('#88ccff'),
            colorOutside: new THREE.Color('#ffffff')
        };
        
        // --- ÂõæÁâáÂàóË°® ---
        const IMG_FILES = [
            'https://cdn.jsdelivr.net/gh/vivianlymm-li/my-image-hosting@main/img/retouch_2025122015250149.jpg', 
            'https://picsum.photos/id/1016/300/400',
            'https://picsum.photos/id/1018/300/400', 
            'https://picsum.photos/id/1019/300/400',
            'https://picsum.photos/id/1020/300/400', 
            'https://picsum.photos/id/1021/300/400',
            'https://picsum.photos/id/1022/300/400', 
            'https://picsum.photos/id/1023/300/400',
            'https://picsum.photos/id/1024/300/400', 
            'https://picsum.photos/id/1025/300/400',
            'https://picsum.photos/id/1026/300/400', 
            'https://picsum.photos/id/1027/300/400'
        ];

        const BLESSINGS = [
            "Merry Christmas", "Happy New Year", "Joy & Peace", "Warm Wishes",
            "Holiday Cheer", "Season's Greetings", "Magic Moments", "Stay Cozy",
            "Love & Light", "Best Wishes", "Dreams Come True", "Be Happy"
        ];

        let scene, camera, renderer, composer, controls;
        let treePoints, trunkPoints, twinklePoints; 
        let topStarSpherePoints, topStarRing1Points, topStarRing2Points;
        let photoGroup; 
        let time = 0;

        let targetMorph = 0.0; 
        let currentMorph = 0.0;
        let isHandOpen = false;
        let isPinching = false;
        
        // ÊâãÂäø‰∫§‰∫íÁõ∏ÂÖ≥
        let lastHandX = undefined;
        let currentHandX = 0.5; 
        let rotationVelocity = 0;
        let activeCard = null;

        // Áä∂ÊÄÅÁõ∏ÂÖ≥
        let treeBuildStarted = false; 
        let treeBuildProgress = 0.0; 
        let unlockProgress = 0.0;

        // --- ÁªàÁ´†Ê®°ÂºèÁä∂ÊÄÅ ---
        let finaleActive = false;
        let finaleProgress = 0.0;
        let finaleTriggered = false; 

        // ÊëÑÂÉèÊú∫ÂÖ≥ÈîÆ‰ΩçÁΩÆ
        const treeCamPos = new THREE.Vector3(0, 12, 50);   
        const galaxyCamPos = new THREE.Vector3(0, 12, 25); 
        const centerCamPos = new THREE.Vector3(0, 10, 0);  

        // --- Èü≥‰πêÊéßÂà∂ÈÄªËæë ---
        const bgm = document.getElementById('bgm');
        const musicBtn = document.getElementById('music-control');
        let musicStarted = false;

        function toggleMusic() {
            if (bgm.paused) {
                bgm.play().then(() => {
                    musicBtn.classList.add('music-playing');
                    musicBtn.innerHTML = 'üéµ';
                    musicStarted = true;
                }).catch(e => {
                    console.log("Audio play blocked", e);
                });
            } else {
                bgm.pause();
                musicBtn.classList.remove('music-playing');
                musicBtn.innerHTML = 'üîá';
            }
        }

        // ÁªëÂÆöÊåâÈíÆ‰∫ã‰ª∂
        musicBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            toggleMusic();
            musicStarted = true;
        });

        // Â∞ùËØïËá™Âä®Êí≠Êîæ
        document.body.addEventListener('click', () => {
            if (!musicStarted) {
                bgm.play().then(() => {
                    musicBtn.classList.add('music-playing');
                    musicStarted = true;
                }).catch(() => {});
            }
        }, { once: true });


        function initScene() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            const ambientLight = new THREE.AmbientLight(0x404040, 2.0);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x88ccff, 1.0); 
            backLight.position.set(-10, 10, -20);
            scene.add(backLight);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(treeCamPos);
            camera.lookAt(0, 10, 0); 

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            renderer.toneMapping = THREE.NoToneMapping; 
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.target.set(0, 10, 0);
            controls.saveState();

            const renderScene = new RenderPass(scene, camera);
            // [ÂÖ≥ÈîÆ] ËæâÂÖâÈòàÂÄºËÆæ‰∏∫ 1.01
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.0;  
            bloomPass.radius = 0.6;
            bloomPass.threshold = 1.01; 

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
        }

        // ËæÖÂä©ÂáΩÊï∞
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function addGalaxyAttribute(geometry, count, radiusScale = 1.0, yCenterOffset = 10) {
            const positions = [];
            const rBase = CONFIG.galaxyRadius * radiusScale;

            for(let i=0; i<count; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(clamp(2 * v - 1, -1, 1));
                const r = rBase * Math.pow(Math.random(), 0.3333); 
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta) + yCenterOffset; 
                const z = r * Math.cos(phi);
                
                positions.push(
                    isNaN(x) ? 0 : x, 
                    isNaN(y) ? 0 : y, 
                    isNaN(z) ? 0 : z
                );
            }
            geometry.setAttribute('aGalaxyPos', new THREE.Float32BufferAttribute(positions, 3));
        }

        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255, 255, 255, 1)');
            g.addColorStop(0.5, 'rgba(100, 160, 255, 0.15)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
            g.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 128, 128);
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                ctx.lineTo(cx + Math.cos(angle) * 60, cy + Math.sin(angle) * 60);
                const midAngle = angle + Math.PI / 4;
                ctx.quadraticCurveTo(cx, cy, cx + Math.cos(midAngle) * 8, cy + Math.sin(midAngle) * 8);
            }
            ctx.closePath(); ctx.fillStyle = '#ffffff'; ctx.fill();
            ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 255, 255, 1.0)'; ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const commonVertexShader = `
            attribute float aSize;
            attribute float aRandom;
            attribute vec3 aColor;
            attribute vec3 aGalaxyPos;
            varying vec3 vColor;
            uniform float uTime;
            uniform float uMorph;
            uniform sampler2D uTexture;
            void main() {
                vColor = aColor;
                vec3 treePos = position;
                if (uMorph < 0.99) {
                    float wave = sin(uTime * 1.5 + treePos.y * 0.5);
                    treePos.y += wave * 0.08;
                }
                float t = uMorph;
                t = t * t * (3.0 - 2.0 * t);
                vec3 pos = mix(treePos, aGalaxyPos, t);
                if (uMorph > 0.01) {
                    pos.x += sin(uTime * 0.5 + aRandom * 10.0) * 0.1 * uMorph;
                    pos.z += cos(uTime * 0.3 + aRandom * 10.0) * 0.1 * uMorph;
                }
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                float baseSize = aSize * (350.0 / -mvPosition.z);
                float twinkle = sin(uTime * 3.0 + aRandom * 10.0);
                float flashSize = baseSize * (0.8 + twinkle * 0.3);
                gl_PointSize = max(2.0, flashSize); 
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const commonFragmentShader = `
            uniform sampler2D uTexture;
            uniform float uOpacity; 
            varying vec3 vColor;
            void main() {
                vec4 texColor = texture2D(uTexture, gl_PointCoord);
                if (texColor.a < 0.05) discard;
                // [ÂÖ≥ÈîÆ‰øÆÊîπ] Á≤íÂ≠ê‰∫ÆÂ∫¶‰πò 2.0Ôºå‰ΩøÂÖ∂Ë∂ÖËøáÈòàÂÄº 1.01Ôºå‰ªéËÄåÂèëÂÖâ
                gl_FragColor = vec4(vColor * 2.0, 1.0) * texColor;
                gl_FragColor.a *= uOpacity; 
            }
        `;

        function createTrunk() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const count = 400; 
            const topY = CONFIG.treeHeight * 0.7; const bottomY = -2.0; const totalH = topY - bottomY;
            const baseR = 3; const topR = 0.3;  
            const texture = createSparkleTexture();

            for (let i = 0; i < count; i++) {
                const hRatio = Math.random(); 
                const y = bottomY + hRatio * totalH;
                const currentR = baseR * (1 - hRatio) + topR * hRatio;
                const angle = Math.random() * Math.PI * 2;
                const r = currentR * Math.sqrt(Math.random()) + (Math.random() - 0.5) * 0.8;
                let x = Math.cos(angle) * r;
                let z = Math.sin(angle) * r;
                if (hRatio < 0.15) {
                    const scatter = Math.pow(Math.max(0, 1.0 - hRatio / 0.15), 2.0);
                    const spread = 4.0 * scatter; 
                    x += (Math.random() - 0.5) * spread; z += (Math.random() - 0.5) * spread;
                }
                positions.push(x, y, z);
                const brightness = 2 + Math.random() * 0.1; 
                colors.push(0.1 * brightness, 0.2 * brightness, 0.5 * brightness);
                sizes.push(Math.random() * 1 + 0.6);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3)); 
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));    
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, count, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            trunkPoints = new THREE.Points(geometry, material);
            scene.add(trunkPoints);
        }

        function createTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const texture = createSparkleTexture();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const p = i / CONFIG.particleCount; 
                const angle = p * Math.PI * 2 * CONFIG.spiralLoops;
                // [‰øÆÂ§ç] Èò≤Ê≠¢ Math.pow Ë¥üÊï∞Â∫ïÊï∞
                const baseRadius = CONFIG.baseRadius * Math.pow(Math.max(0, 1.0 - p), 1.2); 
                const baseHeight = p * CONFIG.treeHeight;
                const wavePhase = angle * 2.5; 
                const currentAmp = CONFIG.waveAmplitude * Math.pow(Math.max(0, 1.0 - p), 1.0);
                const yWave = Math.sin(wavePhase) * currentAmp;
                const rWave = Math.cos(wavePhase) * currentAmp * 0.8;
                let centerY = baseHeight + yWave; let centerR = baseRadius + rWave;
                let widthFactor = p > 0.4 ? 1.0 - (p - 0.4) * 0.5 : 1.0;
                const currentWidth = CONFIG.ribbonWidth * widthFactor;
                const v = Math.random() - 0.5; 
                const twistAmp = 0.5 * Math.pow(Math.max(0, 1.0 - p), 2.0);
                const tiltAngle = Math.cos(wavePhase) * twistAmp;
                const rOffset = v * currentWidth * Math.cos(tiltAngle);
                const yOffset = v * currentWidth * Math.sin(tiltAngle);
                let rFinal = centerR + rOffset; let yFinal = centerY + yOffset;
                const normalizedPos = v + 0.5; 
                yFinal -= Math.pow(normalizedPos, 2) * currentWidth * 0.5;
                yFinal += (Math.random() - 0.5) * 0.15;
                let x = Math.cos(angle) * rFinal; let z = Math.sin(angle) * rFinal;

                let scatterFactor = 0;
                const tailRegion = 0.15;
                if (p < tailRegion) {
                    scatterFactor = Math.pow(Math.max(0, 1.0 - (p / tailRegion)), 2.0);
                    const flare = 0.7 * scatterFactor; 
                    x += Math.cos(angle) * flare; z += Math.sin(angle) * flare;
                    const chaosRadius = 3.0 * scatterFactor; x += (Math.random() - 0.5) * chaosRadius; z += (Math.random() - 0.5) * chaosRadius;
                    yFinal += (Math.random() - 0.5) * scatterFactor * 0.2;
                }
                
                if (isNaN(x)) x = 0;
                if (isNaN(yFinal)) yFinal = 0;
                if (isNaN(z)) z = 0;

                positions.push(x, yFinal, z);

                const mixFactor = Math.random();
                const mixedColor = CONFIG.colorInside.clone().lerp(CONFIG.colorOutside, mixFactor);
                const brightnessFactor = (1.0 - Math.pow(p, 1.8) * 0.6) * 0.6;
                mixedColor.multiplyScalar(brightnessFactor);
                if (scatterFactor > 0) mixedColor.multiplyScalar(1.0 - scatterFactor * 0.7);
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
                
                let size = Math.random() * 1.0 + 0.2; 
                size *= (1.0 - p * 0.3);
                if (scatterFactor > 0) size *= (1.0 - scatterFactor * 0.6);
                sizes.push(size);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, CONFIG.particleCount, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            treePoints = new THREE.Points(geometry, material);
            scene.add(treePoints);
        }

        function createTwinkles() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = []; const randoms = [];
            const count = 500; const texture = createStarTexture();

            for (let i = 0; i < count; i++) {
                const p = Math.random(); const y = p * CONFIG.treeHeight;
                const maxR = CONFIG.baseRadius * (1.0 - p) * 1.2; 
                const r = Math.sqrt(Math.random()) * maxR; const angle = Math.random() * Math.PI * 2;
                let x = Math.cos(angle) * r; let z = Math.sin(angle) * r;
                if (p < 0.1) {
                   const spread = 2.0 * Math.pow(Math.max(0, 1.0 - p / 0.1), 2.0);
                   x += (Math.random() - 0.5) * spread; z += (Math.random() - 0.5) * spread;
                }
                positions.push(x, y, z);
                colors.push(0.9, 0.95, 1.0); 
                sizes.push(Math.random() < 0.05 ? Math.random() * 1.5 + 1.2 : Math.random() * 0.8 + 0.4);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            addGalaxyAttribute(geometry, count, 1.0, 10);

            const material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            twinklePoints = new THREE.Points(geometry, material);
            scene.add(twinklePoints);
        }

        function createTopParticles() {
            const texture = createSparkleTexture();
            const starTexture = createStarTexture();

            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uMorph: { value: 0 }, uTexture: { value: texture }, uOpacity: { value: 1.0 } },
                vertexShader: commonVertexShader,
                fragmentShader: commonFragmentShader,
                depthWrite: false, blending: THREE.AdditiveBlending, transparent: true
            });

            // 1. Ê†∏ÂøÉÁêÉ
            const sGeo = new THREE.BufferGeometry();
            const sPos = []; const sColors = []; const sSizes = []; const sRandoms = [];
            const sphereCount = 2000; const radius = 1.2;
            for(let i=0; i<sphereCount; i++) {
                const u = Math.random(); const v = Math.random();
                const theta = 2 * Math.PI * u; 
                // [‰øÆÂ§ç] clamp acos
                const phi = Math.acos(clamp(2 * v - 1, -1, 1));
                let rRatio = Math.pow(Math.random(), 0.4); let r = radius * rRatio;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                sPos.push(isNaN(x)?0:x, isNaN(y)?0:y, isNaN(z)?0:z); 
                const distNorm = r / radius; const baseB = 0.5 * (1.0 + distNorm * 0.6);
                sColors.push(baseB * 0.2, baseB * 0.6, baseB * 1.0); 
                sSizes.push(Math.random() * 0.4 + 0.2); sRandoms.push(Math.random());
            }
            sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
            sGeo.setAttribute('aColor', new THREE.Float32BufferAttribute(sColors, 3));
            sGeo.setAttribute('aSize', new THREE.Float32BufferAttribute(sSizes, 1));
            sGeo.setAttribute('aRandom', new THREE.Float32BufferAttribute(sRandoms, 1));
            
            const objY = CONFIG.treeHeight + 1.5;
            const galaxyLocalY = 10 - objY;
            addGalaxyAttribute(sGeo, sphereCount, 1.0, galaxyLocalY);

            topStarSpherePoints = new THREE.Points(sGeo, particleMaterial);
            topStarSpherePoints.position.set(0, objY, 0); 
            scene.add(topStarSpherePoints);

            // 2. ÁéØ
            const ringMaterial = particleMaterial.clone();
            ringMaterial.uniforms.uTexture.value = starTexture;

            const createRing = (radius, tiltX, tiltZ) => {
                const rGeo = new THREE.BufferGeometry();
                const rPos = []; const rColors = []; const rSizes = []; const rRandoms = [];
                const ringCount = 400;
                for(let i=0; i<ringCount; i++) {
                    const angle = (i / ringCount) * Math.PI * 2;
                    const scatterR = (Math.random() - 0.5) + (Math.random() - 0.5); 
                    const r = radius + scatterR * 0.5; 
                    let x = Math.cos(angle) * r; let y = (Math.random() - 0.5) * 0.4; let z = Math.sin(angle) * r;
                    let y1 = y * Math.cos(tiltX) - z * Math.sin(tiltX);
                    let z1 = y * Math.sin(tiltX) + z * Math.cos(tiltX);
                    let x2 = x * Math.cos(tiltZ) - y1 * Math.sin(tiltZ);
                    let y2 = x * Math.sin(tiltZ) + y1 * Math.cos(tiltZ);
                    rPos.push(x2, y2, z1); 
                    const distFactor = 1.0 - Math.abs(scatterR) * 0.8; const brightness = 0.4 * distFactor; 
                    rColors.push(brightness, brightness * 1.1, brightness * 1.2); 
                    rSizes.push(Math.random() * 0.6 + 0.4); rRandoms.push(Math.random());
                }
                rGeo.setAttribute('position', new THREE.Float32BufferAttribute(rPos, 3));
                rGeo.setAttribute('aColor', new THREE.Float32BufferAttribute(rColors, 3));
                rGeo.setAttribute('aSize', new THREE.Float32BufferAttribute(rSizes, 1));
                rGeo.setAttribute('aRandom', new THREE.Float32BufferAttribute(rRandoms, 1));
                addGalaxyAttribute(rGeo, ringCount, 1.0, galaxyLocalY);
                return new THREE.Points(rGeo, ringMaterial);
            };

            topStarRing1Points = createRing(2.0, Math.PI * 0.25, Math.PI * 0.1);
            topStarRing1Points.position.set(0, objY, 0);
            scene.add(topStarRing1Points);

            topStarRing2Points = createRing(2.0, -Math.PI * 0.25, -Math.PI * 0.1);
            topStarRing2Points.position.set(0, objY, 0);
            scene.add(topStarRing2Points);
        }

        function createPhotoGallery() {
            photoGroup = new THREE.Group();
            photoGroup.position.set(0, 10, 0); 
            photoGroup.renderOrder = 999; 
            scene.add(photoGroup);

            const count = 12;
            const radius = 10; 
            
            // Áõ∏Ê°ÜÂ∞∫ÂØ∏Ôºö3.5 x 4.5
            const frameWidth = 3.5;
            const frameHeight = 4.5;
            // ÁÖßÁâáÂ∞∫ÂØ∏Ôºö3.2 x 4.2
            const photoWidth = 3.2;
            const photoHeight = 4.2;

            const drawBackground = (ctx, isGolden) => {
                const grd = ctx.createLinearGradient(0, 0, 300, 400);
                if (isGolden) {
                    // [‰øÆÊîπ] ËÉåÈù¢ÊöóÈáëËâ≤
                    grd.addColorStop(0, '#B78727'); 
                    grd.addColorStop(1, '#F7D674'); 
                } else {
                    grd.addColorStop(0, '#001f3f'); 
                    grd.addColorStop(1, '#0072ff'); 
                }
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 300, 400);
            };

            const createBackTexture = (text, isGolden = false) => {
                const canvas = document.createElement('canvas');
                canvas.width = 300; canvas.height = 400;
                const ctx = canvas.getContext('2d');
                drawBackground(ctx, isGolden);
                
                // [‰øÆÊîπ] ËæπÊ°ÜÈ¢úËâ≤ÈÄÇÈÖçÈáëËâ≤ËÉåÊôØ
                ctx.strokeStyle = isGolden ? "rgba(255, 255, 255, 0.9)" : "rgba(255, 255, 255, 0.8)";
                ctx.lineWidth = 15;
                ctx.strokeRect(10, 10, 280, 380);
                
                // [‰øÆÊîπ] ÊñáÂ≠óÈ¢úËâ≤ÈÄÇÈÖç
                ctx.fillStyle = isGolden ? "#5C4033" : "white"; // ÈáëËâ≤ËÉåÊôØÁî®Ê∑±Ë§êËâ≤ÊñáÂ≠ó
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = "bold 40px Arial";
                const words = text.split(' ');
                if (words.length > 2) {
                    ctx.fillText(words.slice(0, Math.ceil(words.length/2)).join(' '), 150, 180);
                    ctx.fillText(words.slice(Math.ceil(words.length/2)).join(' '), 150, 230);
                } else {
                    ctx.fillText(text, 150, 200);
                }
                return new THREE.CanvasTexture(canvas);
            };

            const createGoldenBackTexture = (text) => {
                return createBackTexture(text, true);
            };

            // [Êñ∞Â¢û] ÁªòÂà∂Â§±Ë¥•Êó∂ÁöÑÂç†‰ΩçÁ¨¶ÔºàÊºÇ‰∫ÆÁöÑÁ§ºÁâ©ÁõíÔºâ
            const drawPlaceholder = (ctx) => {
                ctx.fillStyle = '#C0392B'; // ËäÇÊó•Á∫¢Â∫ï
                ctx.fillRect(0, 0, 300, 400); // Â°´Êª°
                
                // ÈáëËâ≤ÂçÅÂ≠ó‰∏ùÂ∏¶
                ctx.fillStyle = '#F1C40F';
                ctx.fillRect(135, 0, 30, 400); // Á´ñ
                ctx.fillRect(0, 185, 300, 30); // Ê®™
                
                // ÊñáÂ≠ó
                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("üéÅ GIFT", 150, 120);
                ctx.font = '20px Arial';
                ctx.fillText("FOR YOU", 150, 160);
            };

            const createFrontTexture = (imgFilename) => {
                const canvas = document.createElement('canvas');
                canvas.width = 300; canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // ÈªòËÆ§Â∫ïËâ≤
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, 300, 400);

                const tex = new THREE.CanvasTexture(canvas);
                const img = new Image();
                img.crossOrigin = "Anonymous";
                
                img.onload = () => {
                    // [‰øÆÊîπ] ÁßªÈô§ËæπÊ°ÜÁªòÂà∂ÔºåÂõæÁâáÈì∫Êª°ÔºåËæπÊ°ÜÁî±Â§ñÈÉ® Mesh Êèê‰æõ
                    ctx.drawImage(img, 0, 0, 300, 400);
                    
                    // [ÂÖ≥ÈîÆ] ËÆæÁΩÆÈ¢úËâ≤Á©∫Èó¥ÂíåÂêÑÂêëÂºÇÊÄßÔºåÈò≤Ê≠¢Ê®°Á≥äÂíåÂèëÁôΩ
                    tex.colorSpace = THREE.SRGBColorSpace; 
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    
                    tex.needsUpdate = true;
                };
                
                // [‰øÆÊîπ] ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•Êó∂ÔºåÁªòÂà∂ÊºÇ‰∫ÆÂç†‰ΩçÂõæÔºåËÄå‰∏çÊòØÈªëÂ±è
                img.onerror = () => {
                    drawPlaceholder(ctx);
                    tex.needsUpdate = true;
                };
                
                if (!imgFilename) {
                    drawPlaceholder(ctx);
                    tex.needsUpdate = true;
                } else {
                    img.src = imgFilename;
                }
                
                return tex;
            };

            // [ÂÖ≥ÈîÆ‰øÆÊîπ] ÊòæÂºèÂÆö‰πâ frameGeometry Âíå photoGeometryÔºåÈò≤Ê≠¢ ReferenceError
            const frameGeometry = new THREE.PlaneGeometry(frameWidth, frameHeight);
            const photoGeometry = new THREE.PlaneGeometry(photoWidth, photoHeight);

            for (let i = 0; i < count; i++) {
                const cardContainer = new THREE.Group();
                const imgFile = IMG_FILES[i % IMG_FILES.length];
                const blessingText = BLESSINGS[i % BLESSINGS.length]; 

                const realPhotoTex = createFrontTexture(imgFile);
                const backTex = createBackTexture(blessingText, false); 

                // 1. Áõ∏Ê°Ü Mesh (Á∫ØÁôΩÔºå‰∫ÆÂ∫¶1.1 -> ÂæÆ‰∫ÆÂèëÂÖâ)
                const frameMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(1.1, 1.1, 1.1), // [ÂÖ≥ÈîÆ] Èôç‰Ωé HDR Âº∫Â∫¶Âà∞ 1.1
                    transparent: true,
                    opacity: 0,
                    side: THREE.FrontSide,
                    depthWrite: false
                });
                const frameMesh = new THREE.Mesh(frameGeometry, frameMat);
                frameMesh.position.z = 0.01;

                // 2. ÁÖßÁâá Mesh (ÂéüËâ≤ 1.0 -> ‰∏çÂèëÂÖâ)
                const photoMat = new THREE.MeshBasicMaterial({
                    map: realPhotoTex,
                    color: 0xffffff, // [ÂÖ≥ÈîÆ] ‰øùÊåÅÂéüÂßã‰∫ÆÂ∫¶ 1.0
                    transparent: true,
                    opacity: 0,
                    side: THREE.FrontSide,
                    depthWrite: true, 
                    fog: false 
                });
                const photoMesh = new THREE.Mesh(photoGeometry, photoMat);
                photoMesh.position.z = 0.02; // Âè†Âä†Âú®Áõ∏Ê°Ü‰πã‰∏ä
                
                // [Êñ∞Â¢û] 3. Â∞ÅÈù¢ Mesh (Êú™Ëß£ÈîÅÁä∂ÊÄÅÔºåËìùËâ≤ÁâåÈù¢)
                const coverMat = new THREE.MeshBasicMaterial({
                    map: backTex, // ÂàùÂßãËìùËâ≤ËÉåÈù¢Á∫πÁêÜ
                    color: 0xffffff, 
                    transparent: true,
                    opacity: 1.0, // ÂàùÂßã‰∏çÈÄèÊòé
                    side: THREE.FrontSide,
                    depthWrite: false
                });
                const coverMesh = new THREE.Mesh(frameGeometry, coverMat);
                coverMesh.position.z = 0.03; // Âú®ÁÖßÁâá‰πã‰∏ä

                // 4. ËÉåÈù¢ Mesh
                const backMat = new THREE.MeshBasicMaterial({
                    map: backTex, 
                    color: 0xcccccc, // [‰øÆÊîπ] Èôç‰ΩéËÉåÈù¢‰∫ÆÂ∫¶Âà∞ 0xcccccc
                    transparent: true,
                    opacity: 0,
                    side: THREE.FrontSide, 
                    depthWrite: false,
                    fog: false 
                });
                const backMesh = new THREE.Mesh(frameGeometry, backMat);
                backMesh.rotation.y = Math.PI; 
                backMesh.position.z = -0.01;

                cardContainer.add(frameMesh);
                cardContainer.add(photoMesh);
                cardContainer.add(coverMesh); // Ê∑ªÂä†ËìùËâ≤Â∞ÅÈù¢
                cardContainer.add(backMesh);
                
                // ÂàùÂßãÂåñ coverAlphaÔºåÁî®‰∫éÁä∂ÊÄÅËøΩË∏™
                cardContainer.userData.coverAlpha = 1.0;

                const angle = (i / count) * Math.PI * 2;
                cardContainer.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                
                cardContainer.lookAt(
                    cardContainer.position.x * 2, 
                    0, 
                    cardContainer.position.z * 2
                );

                cardContainer.userData.originPos = cardContainer.position.clone();
                cardContainer.userData.originQuat = cardContainer.quaternion.clone();
                
                const tempLook = cardContainer.clone();
                tempLook.lookAt(0, 10, 0); 
                cardContainer.userData.inwardQuat = tempLook.quaternion.clone();

                cardContainer.userData.originScale = cardContainer.scale.clone();
                cardContainer.userData.randomOffset = Math.random() * 100;
                
                // ‰øùÂ≠òÂºïÁî®‰ª•‰æøÂä®ÁîªÊõ¥Êñ∞
                cardContainer.userData.frameMat = frameMat;
                cardContainer.userData.photoMat = photoMat;
                cardContainer.userData.backMat = backMat;
                cardContainer.userData.coverMat = coverMat; // ‰øùÂ≠òÂ∞ÅÈù¢ÂºïÁî®

                cardContainer.userData.realPhotoTex = realPhotoTex; 
                cardContainer.userData.isRevealed = false; 
                cardContainer.userData.blessingText = blessingText;
                cardContainer.userData.isGolden = false; 

                cardContainer.renderOrder = 10; 

                photoGroup.add(cardContainer);
            }
            
            photoGroup.userData.createGoldenBackTexture = createGoldenBackTexture;
        }

        // [Êñ∞Â¢û] Áä∂ÊÄÅËøΩË∏™ÂèòÈáèÔºåÁî®‰∫éËøêÈïúÈÄªËæë
        let isAutoMoving = false;

        // --- 4. Âä®ÁîªÂæ™ÁéØ ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.008;

            // Âü∫Á°ÄÁä∂ÊÄÅÈÄªËæë
            if (isHandOpen) {
                targetMorph = 1.0;
            } else {
                targetMorph = 0.0;
            }
            if (isPinching) targetMorph = 1.0;

            currentMorph += (targetMorph - currentMorph) * 0.05; 

            // ÊòüÁ©∫ÊóãËΩ¨ÈÄªËæë
            if (currentMorph > 0.01) {
                const galaxyRotSpeed = 0.0005; 
                if(treePoints) treePoints.rotation.y += galaxyRotSpeed;
                if(trunkPoints) trunkPoints.rotation.y += galaxyRotSpeed;
                if(twinklePoints) twinklePoints.rotation.y += galaxyRotSpeed;
                if(topStarSpherePoints) topStarSpherePoints.rotation.y += galaxyRotSpeed;
            }

            const updateUniforms = (obj) => {
                if(obj && obj.material && obj.material.uniforms && obj.material.uniforms.uMorph) {
                    obj.material.uniforms.uMorph.value = currentMorph;
                    obj.material.uniforms.uTime.value = time;
                }
            };
            updateUniforms(treePoints);
            updateUniforms(trunkPoints);
            updateUniforms(twinklePoints);
            updateUniforms(topStarSpherePoints);
            updateUniforms(topStarRing1Points);
            updateUniforms(topStarRing2Points);

            let revealedCount = 0;
            if (photoGroup) {
                photoGroup.children.forEach(c => {
                    if (c.userData.isRevealed) revealedCount++;
                });
            }
            unlockProgress = revealedCount / 12.0;
            
            if (unlockProgress >= 1.0 && activeCard === null && !finaleTriggered) {
                if (!treeBuildStarted) {
                    treeBuildStarted = true; 
                }
                finaleActive = true; 
                finaleTriggered = true; 
            }
            
            if (finaleActive) {
                finaleProgress += (1.0 - finaleProgress) * 0.02; 
            } else {
                finaleProgress += (0.0 - finaleProgress) * 0.05; 
            }
            
            if (treeBuildStarted) {
                treeBuildProgress += 0.005; 
                if (treeBuildProgress > 1.0) treeBuildProgress = 1.0;
            } else {
                treeBuildProgress = 0.0;
            }

            const finaleHideFactor = Math.max(0, 1.0 - finaleProgress * 2.0);
            
            if (trunkPoints && trunkPoints.material.uniforms) {
                 trunkPoints.material.uniforms.uOpacity.value = finaleHideFactor;
            }

            if (photoGroup) {
                photoGroup.updateMatrixWorld();

                if (activeCard) {
                    rotationVelocity *= 0.5; 
                } else {
                    let baseSpeed = 0.0009;
                    if (finaleActive) {
                        baseSpeed = 0.002; 
                    }
                    
                    let edgeForce = 0;
                    if (isHandOpen && !isPinching) { 
                        if (currentHandX < 0.15) {
                            if (finaleActive) {
                                edgeForce = 0.0025;
                            } else {
                                edgeForce = -0.0025; 
                            }
                        } else if (currentHandX > 0.85) {
                            if (finaleActive) {
                                edgeForce = -0.0025;
                            } else {
                                edgeForce = 0.0025; 
                            }
                        }
                    }

                    rotationVelocity *= 0.95; 
                    rotationVelocity += edgeForce;
                    
                    if (Math.abs(rotationVelocity) < 0.0001) {
                         photoGroup.rotation.y -= baseSpeed;
                    } else {
                         photoGroup.rotation.y += rotationVelocity;
                    }
                }

                photoGroup.children.forEach(cardContainer => {
                    // [‰øÆÊîπ] ÊÅ¢Â§ç‰∏∫Âª∂ËøüÊòæÁé∞Ôºö50% (0.5) ËøõÂ∫¶ÂêéÂºÄÂßãÊòæÁé∞
                    let targetOpacity = (currentMorph - 0.5) * 2.0;
                    targetOpacity = Math.max(0, Math.min(1, targetOpacity));
                    
                    if (cardContainer.userData.frameMat) cardContainer.userData.frameMat.opacity = targetOpacity;
                    if (cardContainer.userData.photoMat) cardContainer.userData.photoMat.opacity = targetOpacity;
                    if (cardContainer.userData.backMat) cardContainer.userData.backMat.opacity = targetOpacity;
                    
                    // [‰øÆÊîπ] Áã¨Á´ãËÆ°ÁÆóÂ∞ÅÈù¢ÁöÑÊ∑°ÂÖ•Ê∑°Âá∫
                    if (cardContainer.userData.coverMat) {
                        // 1. Êú¨Âú∞Áä∂ÊÄÅÔºàÊòØÂê¶Ë¢´Êè≠ÂºÄÔºâÔºöÊè≠ÂºÄ=0ÔºåÊú™Êè≠ÂºÄ=1ÔºåÂ∏¶Âπ≥ÊªëËøáÊ∏°
                        let targetRevealAlpha = cardContainer.userData.isRevealed ? 0.0 : 1.0;
                        cardContainer.userData.coverAlpha = THREE.MathUtils.lerp(
                            cardContainer.userData.coverAlpha,
                            targetRevealAlpha,
                            0.1
                        );
                        
                        // 2. ÂÖ®Â±ÄÁä∂ÊÄÅÔºàÊòØÂê¶ËøõÂÖ•ÊòüÁ©∫ÔºâÔºöÁõ¥Êé•ÂêåÊ≠•Ôºå‰∏çÂ∏¶Âπ≥ÊªëÔºåËß£ÂÜ≥‚ÄúÊÖ¢‰∏ÄÊãç‚ÄùÈóÆÈ¢ò
                        // ÊúÄÁªà‰∏çÈÄèÊòéÂ∫¶ = Êú¨Âú∞Áä∂ÊÄÅ * ÂÖ®Â±ÄÁä∂ÊÄÅ
                        cardContainer.userData.coverMat.opacity = cardContainer.userData.coverAlpha * targetOpacity;
                        
                        // ‰ºòÂåñÔºöÁúã‰∏çËßÅÊó∂ÂÖ≥Èó≠Ê∑±Â∫¶ÂÜôÂÖ•
                        cardContainer.userData.coverMat.depthWrite = cardContainer.userData.coverMat.opacity > 0.1;
                    }

                    if (cardContainer === activeCard) {
                        cardContainer.renderOrder = 9999;
                        
                        if (cardContainer.userData.frameMat) {
                            cardContainer.userData.frameMat.depthTest = false;
                            cardContainer.userData.frameMat.depthWrite = false;
                        }
                        if (cardContainer.userData.photoMat) {
                            cardContainer.userData.photoMat.depthTest = false;
                            cardContainer.userData.photoMat.depthWrite = false;
                        }
                        if (cardContainer.userData.backMat) {
                            cardContainer.userData.backMat.depthTest = false;
                            cardContainer.userData.backMat.depthWrite = false;
                        }
                        if (cardContainer.userData.coverMat) { // Â∞ÅÈù¢‰πüÂÖ≥Èó≠Ê∑±Â∫¶ÊµãËØï
                            cardContainer.userData.coverMat.depthTest = false;
                            // depthWrite Áî±‰∏äÈù¢ÈÄªËæëÊéßÂà∂
                        }

                        if (cardContainer.userData.frameMat) cardContainer.userData.frameMat.opacity = 1.0;
                        if (cardContainer.userData.photoMat) cardContainer.userData.photoMat.opacity = 1.0;
                        if (cardContainer.userData.backMat) cardContainer.userData.backMat.opacity = 1.0;

                        if (!cardContainer.userData.isRevealed) {
                            cardContainer.userData.isRevealed = true;
                            
                            if (!cardContainer.userData.isGolden) {
                                cardContainer.userData.isGolden = true;
                                const goldTex = photoGroup.userData.createGoldenBackTexture(cardContainer.userData.blessingText);
                                cardContainer.userData.backMat.map = goldTex;
                                cardContainer.userData.backMat.needsUpdate = true;
                            }
                        }

                        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        const targetWorldPos = camera.position.clone().add(forward.multiplyScalar(14));
                        const targetLocalPos = photoGroup.worldToLocal(targetWorldPos.clone());

                        const groupWorldQuat = new THREE.Quaternion();
                        photoGroup.getWorldQuaternion(groupWorldQuat);
                        const groupInv = groupWorldQuat.invert();
                        const targetQuat = groupInv.multiply(camera.quaternion);

                        cardContainer.position.lerp(targetLocalPos, 0.1);
                        cardContainer.quaternion.slerp(targetQuat, 0.2);
                        
                        const pulse = 1.0 + Math.sin(time * 3.0) * 0.05; 
                        const targetScale = new THREE.Vector3(3.2 * pulse, 3.2 * pulse, 3.2 * pulse);
                        cardContainer.scale.lerp(targetScale, 0.1);

                    } else {
                        cardContainer.renderOrder = 10;
                        
                        if (cardContainer.userData.frameMat) {
                            cardContainer.userData.frameMat.depthTest = true;
                            cardContainer.userData.frameMat.depthWrite = false;
                        }
                        if (cardContainer.userData.photoMat) {
                            cardContainer.userData.photoMat.depthTest = true;
                            cardContainer.userData.photoMat.depthWrite = false;
                        }
                        if (cardContainer.userData.backMat) {
                            cardContainer.userData.backMat.depthTest = true;
                            cardContainer.userData.backMat.depthWrite = false;
                        }
                        if (cardContainer.userData.coverMat) {
                            cardContainer.userData.coverMat.depthTest = true;
                        }

                        cardContainer.position.lerp(cardContainer.userData.originPos, 0.05);
                        
                        const floatY = Math.sin(time * 1.5 + cardContainer.userData.randomOffset) * 0.2;
                        const targetPosWithFloat = cardContainer.userData.originPos.clone();
                        targetPosWithFloat.y += floatY;
                        cardContainer.position.lerp(targetPosWithFloat, 0.05);

                        if (finaleProgress > 0.01) {
                            const currentQ = cardContainer.userData.originQuat.clone();
                            const targetQ = cardContainer.userData.inwardQuat.clone();
                            currentQ.slerp(targetQ, finaleProgress); 
                            cardContainer.quaternion.slerp(currentQ, 0.05);
                        } else {
                            cardContainer.quaternion.slerp(cardContainer.userData.originQuat, 0.05);
                        }
                        
                        cardContainer.scale.lerp(cardContainer.userData.originScale, 0.05);
                    }
                });
            }

            if (isHandOpen || finaleActive || currentMorph > 0.001 || finaleProgress > 0.001) {
                isAutoMoving = true;
            }

            if (isAutoMoving) {
                controls.enabled = false;

                let targetCamPos = treeCamPos.clone(); 
                
                targetCamPos.lerp(galaxyCamPos, currentMorph);
                
                if (finaleProgress > 0.001) {
                    targetCamPos.lerp(centerCamPos, finaleProgress);
                }

                camera.position.copy(targetCamPos);
                camera.lookAt(0, 10, 0);

                if (!isHandOpen && !finaleActive && currentMorph < 0.001 && finaleProgress < 0.001) {
                    isAutoMoving = false;
                    controls.enabled = true;
                    controls.target.set(0, 10, 0); 
                    controls.update();
                }
            } else {
                controls.enabled = true;
                controls.update();
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 5. MediaPipe ÊâãÂäøËØÜÂà´ ---
        function initMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const statusText = document.getElementById('status-text');
            const instructionText = document.getElementById('instruction-text');
            const loading = document.getElementById('loading');

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
            
            // ÂàùÂßãÂåñ Face Detection
            const faceDetection = new FaceDetection({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4.1646425229/${file}`;
            }});
            faceDetection.setOptions({
                modelSelection: 0,
                minDetectionConfidence: 0.5
            });
            faceDetection.onResults(onFaceResults);
            
            let faceCheckActive = true;
            
            function onFaceResults(results) {
                if (results.detections && results.detections.length > 0) {
                    if (!musicStarted) {
                        console.log("Face detected, attempting to play music...");
                        toggleMusic(); 
                    }
                    faceCheckActive = false; // Ê£ÄÊµãÂà∞‰∏ÄÊ¨°ÂêéÂç≥ÂÅúÊ≠¢ÔºåËäÇÁúÅÊÄßËÉΩ
                }
            }

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                    // Â¶ÇÊûúÈü≥‰πêËøòÊ≤°ÂºÄÂßãÔºå‰∏îÊ≤°Ê£ÄÊµãÂà∞Ëøá‰∫∫ËÑ∏ÔºåÂàôÊ£ÄÊµã‰∫∫ËÑ∏
                    if (faceCheckActive && !musicStarted) {
                        try {
                            await faceDetection.send({image: videoElement});
                        } catch (e) {
                            console.warn("Face detection send failed, might be uninitialized or conflict", e);
                        }
                    }
                },
                width: 640,
                height: 480
            });

            cameraUtils.start()
                .then(() => {
                    loading.style.opacity = 0;
                    setTimeout(() => loading.style.display = 'none', 500);
                    console.log("Camera started");
                })
                .catch(err => {
                    console.error(err);
                    loading.innerText = "ÊëÑÂÉèÂ§¥ÂêØÂä®Â§±Ë¥• (ËØ∑ÂÖÅËÆ∏ÊùÉÈôê)";
                    statusText.innerText = "Camera Error";
                });
            
            function onResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const wrist = landmarks[0];
                    const thumbTip = landmarks[4];
                    
                    const currX = wrist.x;
                    // Êõ¥Êñ∞ÂÖ®Â±ÄÊâãÈÉ®‰ΩçÁΩÆÔºåÁî®‰∫éËæπÁºòÊªöÂä®
                    currentHandX = currX;

                    if (typeof lastHandX !== 'undefined') {
                        const delta = currX - lastHandX;
                        // ÊôÆÈÄöÊå•ÊâãÈÄªËæë (‰øùÁïôÔºå‰Ωú‰∏∫Âø´ÈÄü‰∫§‰∫íË°•ÂÖÖ)
                        // [ÂÖ≥ÈîÆ‰øÆÂ§ç] ÁßªÈô§ !finaleActive ÈôêÂà∂ÔºåÂÖÅËÆ∏ÁªàÁ´†Ê®°ÂºèÊâãÂä®ÊóãËΩ¨
                        if (!activeCard && isHandOpen) {
                            if (finaleActive) {
                                // ÁªàÁ´†Ê®°Âºè: ÂêëÂ∑¶Êå•(delta<0) -> ÈÄÜÊó∂Èíà(vel>0); ÂêëÂè≥Êå•(delta>0) -> È°∫Êó∂Èíà(vel<0)
                                rotationVelocity -= delta * 0.35; 
                            } else {
                                // ÊôÆÈÄöÊ®°Âºè: ÂêëÂ∑¶Êå•(delta<0) -> È°∫Êó∂Èíà(vel<0); ÂêëÂè≥Êå•(delta>0) -> ÈÄÜÊó∂Èíà(vel>0)
                                rotationVelocity += delta * 0.35; 
                            }
                        }
                    }
                    lastHandX = currX;

                    const tips = [4, 8, 12, 16, 20]; 
                    let avgDist = 0;
                    tips.forEach(idx => {
                        const tip = landmarks[idx];
                        const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                        avgDist += d;
                    });
                    avgDist /= 5;
                    
                    const indexTip = landmarks[8];
                    const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                    const PINCH_THRESHOLD = 0.05; 
                    const OPEN_THRESHOLD = 0.25;  

                    const otherTips = [8, 12, 16, 20];
                    let fiveFingerDist = 0;
                    otherTips.forEach(id => {
                        const t = landmarks[id];
                        fiveFingerDist += Math.sqrt(Math.pow(t.x - thumbTip.x, 2) + Math.pow(t.y - thumbTip.y, 2));
                    });
                    fiveFingerDist /= 4;
                    const isFiveFingerPinch = fiveFingerDist < 0.1; 

                    if (pinchDist < PINCH_THRESHOLD) {
                        if (isFiveFingerPinch) {
                             isPinching = false;
                             isHandOpen = false; 
                             activeCard = null;
                             
                             // [ÂÖ≥ÈîÆ‰øÆÊîπ] Âº∫Âà∂ÈáçÁΩÆÊâÄÊúâÁªàÁ´†Áä∂ÊÄÅÔºåÁ°Æ‰øùÈïúÂ§¥ËÉΩÊãâÂõû Tree Mode
                             finaleActive = false;
                             // finaleProgress Â∞ÜÂú® animate Âæ™ÁéØ‰∏≠Âπ≥ÊªëÂΩíÈõ∂

                             statusText.innerText = "Tree Mode";
                             statusText.style.color = "#ffffff";
                             instructionText.innerText = "üñêÔ∏è OPEN YOUR HAND";
                             
                             // [ÂÖ≥ÈîÆ] ÁßªÈô§ controls.reset()ÔºåÊ∂àÈô§ÈïúÂ§¥ÊäΩÊêê

                        } else {
                            isPinching = true;
                            isHandOpen = true; 
                            statusText.innerText = "Memory Unlocked";
                            statusText.style.color = "#ffcc00";
                            instructionText.innerText = "MERRY CHRISTMAS";

                            if (!activeCard && photoGroup) {
                                let bestMetric = finaleActive ? -Infinity : Infinity; 
                                let closest = null;
                                
                                // Ëé∑ÂèñÊëÑÂÉèÊú∫ÊúùÂêë (Áî®‰∫éÁªàÁ´†Ê®°ÂºèÂà§Êñ≠Ê≠£ÂâçÊñπ)
                                const camDir = new THREE.Vector3();
                                camera.getWorldDirection(camDir);
                                
                                photoGroup.children.forEach(group => {
                                    const worldPos = new THREE.Vector3();
                                    group.getWorldPosition(worldPos);
                                    
                                    if (finaleActive) {
                                        // ÁªàÁ´†Ê®°ÂºèÔºöÈÄâÊã©‰∏éÈïúÂ§¥ÊúùÂêëÊúÄ‰∏ÄËá¥ÁöÑÂç°Áâá
                                        const vecToCard = worldPos.clone().sub(camera.position).normalize();
                                        const dot = camDir.dot(vecToCard);
                                        if (dot > bestMetric) {
                                            bestMetric = dot;
                                            closest = group;
                                        }
                                    } else {
                                        // ÊôÆÈÄöÊ®°ÂºèÔºöÈÄâÊã©Ë∑ùÁ¶ªÊúÄËøëÁöÑÂç°Áâá
                                        const dist = worldPos.distanceTo(camera.position);
                                        if (dist < bestMetric) {
                                            bestMetric = dist;
                                            closest = group;
                                        }
                                    }
                                });
                                if (closest) activeCard = closest;
                            }
                        }

                    } else if (avgDist > OPEN_THRESHOLD) {
                        isPinching = false;
                        isHandOpen = true; 
                        activeCard = null;
                        
                        if (finaleActive) {
                            statusText.innerText = "Grand Finale";
                            statusText.style.color = "#ff88cc";
                            instructionText.innerText = "MERRY CHRISTMAS";
                        } else {
                            statusText.innerText = "Galaxy Mode";
                            statusText.style.color = "#88ccff";
                            instructionText.innerText = "wave your hand / pick any one you want";
                        }

                    } else if (isFiveFingerPinch) {
                        isPinching = false;
                        isHandOpen = false; 
                        activeCard = null;
                        
                        // [ÂÖ≥ÈîÆ‰øÆÊîπ] Âº∫Âà∂ÈáçÁΩÆÁªàÁ´†Áä∂ÊÄÅ
                        finaleActive = false;

                        statusText.innerText = "Tree Mode";
                        statusText.style.color = "#ffffff";
                        instructionText.innerText = "üñêÔ∏è OPEN YOUR HAND";
                        
                        // [ÂÖ≥ÈîÆ] ÁßªÈô§ controls.reset()ÔºåÊ∂àÈô§ÈïúÂ§¥ÊäΩÊêê

                    } else {
                        isPinching = false;
                        activeCard = null;
                    }
                } else {
                    isPinching = false;
                    activeCard = null;
                    lastHandX = undefined; 
                    currentHandX = 0.5; // Reset
                    
                    if (isHandOpen) {
                    } else {
                         statusText.innerText = "MERRY CHRISTMAS";
                         statusText.style.color = "#ffffff";
                    }
                }
            }
        }

        initScene();
        createTrunk();
        createTree();
        createTwinkles(); 
        createTopParticles();
        createPhotoGallery(); 
        animate();
        
        setTimeout(initMediaPipe, 1000);

    </script>
</body>
</html>
